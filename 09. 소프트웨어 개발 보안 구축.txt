
# 01. Secure SDLC

* Secure SDLC
- 보안상 안전한 소프트웨어를 개발하기 위해 'SDLC에 보안 강화를 위한 프로세스를 포함한 것'
  -- 소프트웨어 개발 생명주기 (SDLC, Software Development Life Cycle)
     - 소프트웨어 개발 방법론의 바탕이 되는 것
     - 소프트웨어를 개발하기 위해 정의하고, 운용, 유지보수 등의 전 과정을 각 단계별로 나눈 것
- 요구사항 분석, 설계, 구현, 테스트, 유지보수 등 SDLC 전체 단계에 걸쳐 수행되어야 할 보안 활동을 제시함

** Secure SDLC의 대표적인 방법론
1) CLASP : SDLC의 '초기 단계'에서 '보안을 강화'하기 위해 개발된 방법론
2) SDL : 마이크로소프트 사에서 '안전한 소프트웨어 개발'을 위해 '기존의 SDLC를 개선'한 방법론
3) Seven Touchpoints : 소프트웨어 보안의 '모범사례를 SDLC에 통합한 방법론'

* SDLC 단계별 보안 활동
1) 요구사항 분석 단계 : 보안 항목에 해당하는 요구사항을 식별하는 작업 수행
2) 설계 단계 : 식별된 보안 요구사항들을 소프트웨어 설계서에 반영하고, 보안 설계서를 작성
3) 구현 단계 : 표준 코딩 정의서 및 소프트웨어 개발 보안 가이드를 준수하며, 설계서에 따라 보안 요구사항들을 구현함
4) 테스트 단계 : 설계 단계에서 작성한 보안 설계서를 바탕으로 보안 사항들이 정확히 반영되고 동작하는지 점검
5) 유지보수 단계 : 이전 과정을 모두 수행하였음에도 발생할 수 있는 보안사고들을 식별함 / 사고 발생 시, 이를 해결하고 보안 패치를 실시함

* 소프트웨어 개발 보안 요소
1) 기밀성 (Confidentiality) : 시스템 내의 정보와 자원은 '인가된 사용자에게만 접근 허용' / 정보가 전송 중에 노출되더라도 데이터를 읽을 수 없음
2) 무결성 (Integrity) : 시스템 내의 정보는 오직 '인가된 사용자만 수정'할 수 있음
3) 가용성 (Availability) : 인가받은 사용자는 시스템 내의 '정보와 자원을 언제라도 사용'할 수 있음
4) 인증 (Authentication) : 시스템 내의 정보와 자원을 사용하려는 사용자가 합법적인 사용자인지를 확인하는 모든 행위 / 대표적 방법 : 패스워드, 인증용 카드, 지문 검사 등
5) 부인 방지 (NonRepudiation) : 데이터를 송수신한 자가 송수신 사실을 부인할 수 없도록 송수신 증거를 제공

* 시큐어 코딩 (Secure Coding)
- '구현 단계' 에서 발생할 수 있는 보안 취약점들을 최소화하기 위해 '보안 요소들을 고려하여 코딩하는 것'
- 보안 취약점을 사전 대응하여 '안정성' 과 '신뢰성'을 확보
- 보안 정책을 바탕으로 시큐어 코딩 가이드를 작성하고, 개발 참여자에게는 시큐어 코딩 교육을 실시

# 02. 세션 통제

* 세션 통제
- '세션의 연결과 연결로 인해 발생하는 정보를 관리하는 것'
- 소프트웨어 개발 과정 중, '요구사항 분석 및 설계 단계' 에서 진단해야 하는 보안 점검 내용

** 세션 통제의 보안 약점
- 불충분한 세션 관리 : 일정한 규칙이 존재하는 '세션ID' 가 발급되거나, 타임아웃이 너무 길게 설정되어 있는 경우 발생하는 보안 약점
- 잘못된 세션에 의한 정보 노출 : '다중 스레드(Multi-Thread)' 환경에서 맴버 변수에 정보를 저장할 때 발생하는 보안 약점

*** 세션ID (Session ID) : 서버가 클라이언트들을 구분하기 위해 부여하는 키(Key)로, 클라이언트가 서버에 요청을 보낼 때마다 세션ID를 통해 인증이 수행됨

* 세션 설계 시 고려 사항
- 시스템의 모든 페이지에서 로그아웃이 가능하도록 'UI(User Interface)' 를 구성
- 로그아웃 요청 시, 할당된 세션이 완전히 제거되도록 함
- '세션 타임아웃' 은 중요도가 높으면 '2~5분' 낮으면 '15~30분' 으로 설정
- 이전 세션이 종료되지 않으면 새 세션이 생성되지 못하도록 설계
- 중복 로그인을 허용하지 않은 경우, 클라이언트의 중복 접근에 대한 세션 관리 정책을 수립함

* 세션 ID의 관리 방법
- 세션 ID는 안전한 서버에서 최소 '128비트의 길이' 로 생성
- 세션 ID의 예측이 불가능하도록 안전한 '난수 알고리즘' 을 적용
- 세션 ID가 노출되지 않도록 URL Rewrite 기능을 사용하지 않는 방향으로 설계
  -- URL Rewrite : 쿠키를 사용할 수 없는 환경에서 세선 ID 전달을 위해 URL에 세션 ID를 포함시키는 것
- 로그인 시 로그인 전의 세션 ID를 삭제하고 재할당
- 장기간 접속하고 있는 세션 ID는 주기적으로 지할당되도록 설계함


# 03. 입력 데이터 검증 및 표현

* 입력 데이터 검증 및 표현
- 입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목들

** 입력 데이터 검증 및 표현의 보안 약점
1) SQL 삽입 (Injection)
- 웹 응용 프로그램에 'SQL'을 삽입하여 내부 데이터베이스(DB) 서버의 데이터를 유출 및 변조하고, 관리자 인증을 우회하는 보안 약점
- '동적 쿼리' 에 사용되는 입력 데이터에 '예약어' 및 '특수문자' 가 입력되지 않게 필터링 되도록 설정하여 방지할 수 있음

2) 경로 조작 및 자원 삽입
- 데이터 입출력 경로를 조작하여 서버 자원을 수정, 삭제할 수 있는 보안 약점
- 사용자 입력값을 식별자로 사용하는 경우, '경로 순회 공격'을 막는 필터를 사용하여 방지할 수 있음

3) 크로스사이트 스크립팅 (XSS)
- 웹 페이지에 악의적인 '스크립트' 를 삽입하여 방문자들의 정보를 탈취하거나, 비정상적인 기능 수행을 유발하는 보안 약점
- 'HTML 태그' 의 사용을 제한하거나 스크립트에 삽입되지 않도록 <,>,& 등의 문자를 다른 문자로 치환함으로써 방지할 수 있음

4) 운영체제 명령어 삽입
- 외부 입력값을 통해 시스템 명령어의 실행을 유도함으로써 권한을 탈취하거나 시스템 장애를 유발하는 보안 약점
- 웹 인터페이스를 통해 시스템 명령어가 전달되지 않도록 하고, 외부 입력값을 검증 없이 내부 명령어로 사용하지 않음으로써 방지할 수 있음

5) 위험한 형식 파일 업로드
- 악의적인 명령어가 포함된 스크립트 파일을 업로드함으로써 시스템에 손상을 주거나, 시스템을 제어할 수 있는 보안 약점
- 업로드 되는 파일의 확장자 제한, 파일명의 암호화, 웹사이트와 파일 서버의 경로 분리, 실행 속성을 제거하는 등의 방법으로 방지할 수 있음

6) 신뢰되지 않는 URL 주소로 자동접속 연결
- 입력 값으로 사이트 주소를 받는 경우, 이를 조작하여 방문자를 피싱 사이트로 유도하는 보안 약점
- 연결되는 외부 사이트의 주소를 화이트 리스트로 관리함으로써 방지할 수 있음

7) 메모리 버퍼 오버플로
- 연속된 메모리 공간을 사용하는 프로그램에서 할당된 메모리의 범위를 넘어선 위치에서 자료를 읽거나 쓰려고 할 때 발생하는 보안 취약점
- 메모리 버퍼를 사용할 경우 적절한 버퍼의 크기를 설정하고, 설정된 범위의 메모리 내에서 올바르게 읽거나 쓸 수 있도록 함으로써 방지할 수 있음


# 04. 보안 기능

* 보안 기능
- 소프트웨어 개발의 '구현 단계 '에서 코딩하는 기능인 인증, 접근 제어, 기밀성, 암호화 등을 올바르게 구현하기 위한 보안 점검 항모ㅗㄱ들

** 보안 기능의 보안 약점
1) 적절한 인증 없이 중요 기능 허용
- '보안 검사'를 우회하여 인증 과정 없이 중요한 정보 또는 기능에 접근 및 변경이 가능함
- 중요 정보나 기능을 수행하는 페이지에서는 '재인증 기능' 을 수행하도록 하여 방지할 수 있음

2) 부적절한 인가
- '접근 제어 기능' 이 없는 실행 경로를 통해 정보 또는 권한을 탈취할 수 있음
- 모든 실행 경로에 대해 '접근 제어 검사'를 수행하고, 사용자에게는 반드시 필요한 접근 권한을 부여하여 방지할 수 있음

3) 중요한 자원에 대한 잘못된 권한 설정
- 권한 설정이 잘못된 자원에 접근하여 해당 자원을 임의로 사용할 수 있음
- 소프트웨어 관리자만 자원들을 읽고 쓸 수 있도록 설정하고, 인가되지 않은 사용자의 중요 자원에 대한 접근 여부를 검사함으로써 방지할 수 있음

4) 취약한 암호화 알고리즘
- 암호화된 환경 설정 파일을 해독하여, 비밀번호 등의 중요 정보를 탈취할 수 있음
- 안전한 '암호화 알고리즘' 을 이용하고, 업무 관련 내용이나 개인 정보 등에 대해서는 IT 보안인증사무국이 안정성을 확인한 '암호 모듈'을 이용함으로써 방지할 수 있음

5) 중요정보 평문 저장 및 전송
- 암호화되지 않은 평문 데이터를 탈취하여 중요한 정보를 휙득할 수 있음
- 중요한 정보를 저장하거나 전송할 때는 반드시 암호화 과정을 거치도록 하고 'HTTPS' 또는 'SSL' 과 같은 보안 채널을 이용함으로써 방지할 수 있음

6) 하드코드된 암호화 키
- 암호화된 키도 '하드코드' 된 경우, 유출 시 '역계산' 또는 '무차별 대입 공격' 에 의해 탈취될 수 있음
- 상수 형태의 암호키를 사용하지 않고, 암호화 키 생성 모듈 또는 보안이 보장된 외부 공간을 이용함으로써 방지할 수 있음

*** 하드코드 : 데이터를 코드 내부에 직접 입력하여 프로그래밍하는 방식
*** HTTPS(Hypertext Transfer Protocol Secure) : 웹브라우저와 서버 간의 안전한 통신을 위해 HTTP와 암호 통신규약을 결합한 것
*** SSL(Secure Sockets Layer) : 데이터를 송수신하는 두 컴퓨터 사이에 위치하여 인증, 암호화, 무결성을 보장하는 업계 표준 프로토콜
*** 무차별 대입 공격 (Brute Force Attack) : 암호화된 문서의 암호키를 찾아내기 위해 적용 가능한 모든 값을 대입하여 공격하는 방식

# 05. 시간 및 상태

* 시간 및 상태
- 동시 수행을 지원하는 '병렬 처리 시스템' 이나 다수의 프로세스가 동작하는 환경에서 시간과 실행 상태를 관리하여 시스템이 원할하게 동작되도록 하기 위한 보안 점검 항목들

** 시간 및 상태의 보안 약점
1) TOCTOU 경쟁 조건
- '검사 시점(Time Of Check)' 과 '사용 시점(Time Of Use)' 을 고려하지 않고 코딩하는 경우 발생하는 보안 약점
- 코드 내 '동기화 구문'을 사용하여 해당 자원에는 한 번에 하나의 프로세스만 접근 가능하도록 구성함으로서 방지할 수 있음

2) 종료되지 않는 반복문 또는 재귀 함수
- '반복문' 이나 '재귀 함수' 에서 종료 조건을 정의하지 않았거나, 논리 구조상 종료될 수 없는 경우 발생하는 보안 약점
- 모든 반복문이나 재귀 함수의 수행 횟수를 제한하는 설정을 추가하거나, 종료 조건을 점검하여 반복 또는 호출의 종료 여부를 확인함으로써 방지할 수 있음

*** 경쟁 조건(Race Condition) : 2개 이상의 프로세스가 공용 자원을 휙득하기 위해 경재앟고 있는 상태를 의미, 여기에서는 '검사 시점(TOC)' 과 '사용 시점(TOU)' 의 차이로 발생하는 경쟁 조건을 가리킴
*** 동기화 구문 : 공유 자원에 대해 둘 이상의 프로세스가 접근하는 것을 막는 구문으로, 'Synchronized', 'Mutex' 등이 있음


# 06. 에러 처리

* 에러 처리
- 소프트웨어 실행 중 발생할 수 있는 오류들을 사전에 정의하여 오류로 인해 발생할 수 있는 문제들을 예방하기 위한 보안 점검 항목들
  -- 에러 처리 : 에러는 오류의 영문명이며, '예외 처리(Exception Handling)' 와 '에러(오류) 처리 (Trouble Shooting)' 는 동일한 의미로 사용됨

** 예외 처리의 보안 약점
1) 오류 메시지를 통한 정보 노출
- 오류 발생으로 '실행 환경', '사용자 정보', '대버깅 정보' 등 중요한 정보가 메시지를 통해 외부에 노출되는 보안 약점
- 가능한 한 내부에서만 처리되도록 하거나, 메시지를 출력할 경우 최소한의 정보 또는 사전에 준비된 메시지만 출력되도록 하여 방지할 수 있음

2) 오류 상황 대응 부재
- 소프트웨어 개발 중 에러 처리를 하지 않았거나, 미비로 인해 발생하는 보안 약점
- 오류가 발생할 수 있는 부분에 '에러 처리 구문'을 작성하고, '제어문'을 활용하여 오류가 악용되지 않도록 코딩함으로써 방지할 수 있음

3) 부적절한 예외 처리
- 함수의 반환값 또는 오류들을 세분화하여 처리하지 않고 광범위하게 묶어 한 번에 처리하거나, 누락된 예외가 존재할 때 발생하는 보안 약점
- 모든 함수의 반환값이 의도대로 출력되는지 확인하고, 세분화된 예외 처리를 수행함으로써 방지할 수 있음


# 07. 코드 오류

* 코드 오류
- 소프트웨어 '구현 단계' 에서 개발자들이 코딩 중 실수하기 쉬운 '형(Type) 변환, 자원 변환' 등의 오류를 예방하기 위한 보안 점검 항목들

** 코드 오류의 보안 약점
1) 널 포인터 (Null Pointer) 역참조
- '널 포인터' 가 가리키는 메모리의 위치에 값을 저장할 때 발생하는 보안 약점
- 포인터를 이용하기 전 '널 값'을 갖고 있는지 검사함으로써 방지할 수 있음

2) 부적절한 자원 해제
- 자원을 반환하는 코드를 누락하거나, 프로그램 오류로 할당된 자원을 반환하지 못했을 때 발생하는 보안 약점
- 프로그램 내에 '자원 반환 코드' 가 누락되었는지 확인하고, 오류로 인해 함수가 중간에 종료되었을 때 예외 처리에 관계 없이 자원이 반환되도록 코딩함으로써 방지할 수 있음

3) 해제된 자원 사용
- 이미 사용이 종료되어 반환된 메모리를 참조하는 경우 발생하는 보안 약점
- 반환된 메모리에 접근할 수 없도록 주소를 저장하고, 있는 포인터를 초기화함으로써 방지할 수 있음

4) 초기화되지 않은 변수 사용
- 변수 선언 후 값이 부여되지 않은 변수를 사용할 때 발생하는 보안 약점
- 변수 선언 시 할당된 메모리를 초기화함으로써 방지할 수 있음

*** '널 포인터 역참조'로 오류가 발생하는 경우, "메모리 0x00000000 을 참조하였습니다." 라는 오류 메시지가 발생함

* 스택 가드 (Stack Guard)
- '널 포인터 역참조' 와 같이 '주소가 저장되는 스택에서 발생하는 보안 약점을 막는 기술' 중 하나
- 메모리 상에서 프로그램의 '복귀 주소' 와 '변수' 사이에 특정 값을 저장한 후 그 값이 변경되었을 경우, '오버플로우' 상태로 판단하여 프로그램 실행을 중단함으로써 잘못된 복귀 주소의 호출을 막음


# 08. 캡슐화

* 캡슐화 (Encapsulation)
- '정보 은닉' 이 필요한 중요한 데이터와 기능을 불완전하게 캡슐화 하거나 잘못 사용함으로써 발생할 수 있는 문제를 예방하기 위한 보안 점검항목들

** 캡슐화의 보안 약점
1) 잘못된 세션에 의한 정보 노출
- '다중 스레드(Multi-Thread)' 환경에서 '맴버 변수'에 정보를 저장할 때 발생하는 보안 약점
- '맴버 변수' 보다 '지역 변수' 를 활용하여 변수의 범위를 제한함으로써 방지할 수 있음

2) 제거되지 않고 남은 디버그 코드
- 개발 중 버그 수정이나 결과값 확인을 위해 남겨둔 코드로 인해 발생하는 보안 약점
- 소프트웨어 배포 전에 코드 검사를 수행하여 남아있는 '디버그 코드' 를 삭제함으로써 방지할 수 있음

3) 시스템 데이터 정보 노출
- 시스템의 내부 정보를 시스템 메세지 등을 통해 외부로 출력하도록 코딩했을 때 발생하는 보안 약점
- 노출되는 메시지에는 최소한의 정보만을 제공함으로써 방지할 수 있음

4) Public 메소드로 부터 반환된 Private 배열
- 선언된 클래스 내에서만 접근이 가능한 'Private 배열' 을 모든 클래스에서 접근이 가능한 'Public 메소드' 에서 반환할 때 발생하는 보안 약점
- 'Private 배열' 을 별도의 '메소드' 를 통해 조작하거나, 동일한 형태의 복제본으로 반환받은 후 값을 전달하는 방식으로 방지할 수 있음

5) Private 배열에 Public 데이터 할당
- 'Private 배열'에 'Public' 으로 선언된 데이터 또는 메소드의 '파라미터'를 저장할 때 발생하는 보안 약점
- 'Public' 으로 선언된 데이터를 'Private 배열' 에 저장할 때 '레퍼런스' 가 아닌 값을 직접 저장함으로써 방지할 수 있음

** 레퍼런스(Reference) 를 전달 또는 할당한다는 것은 메모리의 위치를 공유한다는 의미

* 접근 제어자
- 프로그래밍 언어에서 특정 개체를 선언할 때 '외부로부터의 접근을 제한하기 위해 사용되는 예약어'

** 접근 제어자의 종류 (O : 접근 가능, X ; 접근 불가능)

접근 제어자 	클래스 내부	패키지 내부	하위 클래스	패키지 외부
1) Public	    	      O		     O		     O		       O
2) Protected	      O		     O		     O		       X
3) Default   	      O		     O		     X		       X
4) Private    	      O		     X		     X		       X


# 09. API 오용

* API 오용
- 소프트웨어 '구현 단계' 에서 'API'를 잘못 사용하거나 보안에 취약한 'API'를 사용하지 않도록 하기 위한 보안 점검 항목들

* API 오용의 보안 약점
1) DNS Lookup 에 의존한 보안 결정
- '도메인명'에 의존하여 인증이나 접근 통제 등 보안 결정을 내리는 경우 발생하는 보안 약점
- 'DNS 검색'을 통해 도메인 이름을 비교하지 않고, 'IP 주소'를 직접 입력하여 접근함으로서 방지할 수 있음

2) 취약한 API 사용
- 보안 문제로 사용 금지된 API를 사용하거나, 잘못된 방식으로 API를 사용했을 때 발생하는 보안 약점
- 보안 문제로 금지된 함수는 안전한 함수로 대체하고, 'API'의 메뉴얼을 참고하여 보안이 보장되는 '인터페이스' 를 사용함으로써 방지할 수 있음

** DNS(Domain Name System) : 숫자로 된 IP주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것을 '도메인 네임' 이라고 하며, 이러한 도메인 네임을 IP 주소로 바꿔주는 역할을 하는 것


# 10. 암호 알고리즘

* 암호 알고리즘
- 패스워드, 주민번호, 은행 계좌와 같은 '중요 정보를 보호하기 위해 평문을 암호화된 문장으로 만드는 절차 또는 방법'

* 개인키 암호화 (Private Key Encryption) 기법
- '동일한 키' 로 데이터를 '암호화' 하고 '복호화' 하는 암호화 기법
- '대칭 암호 기법' 또는 '단일키 암호화 기법' 이라고도 함
- 암호화/복호화 속도가 '빠르지만' 관리해야 할 키의 수가 '많음'

** 개인키 암호화 기법의 종류
1) 스트림 암호화 방식 : 평문과 동일한 길이의 스트림을 생성하여 '비트 단위'로 암호화 하는 방식 / 종류 : LFSR, RC4
2) 블록 암호화 방식 : 한 번에 하나의 데이터 블록을 암호화 하는 방식 / 종류 : DES, SEED, AES, ARIA

* 공개키 암호화 (Public Key Encryption) 기법
- 데이터를 '암호화' 할 때 사용하는 '공개키(Public Key)'는 사용자에게 '공개하고' '복호화' 할 때의 '비밀키(secret Key)' 는 관리자가 비밀리에 관리하는 암호화 기법
- '비대칭 암호 기법' 이라고도 함
- 관리해야 할 키의 수가 '적지만' , 암호화/복호화 속도가 '느림'
= 대표적으로는 'RSA(Rivest Shamir Adleman)' 기법이 있음















































































































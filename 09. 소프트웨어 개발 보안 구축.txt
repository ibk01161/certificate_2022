
# 01. Secure SDLC

* Secure SDLC
- 보안상 안전한 소프트웨어를 개발하기 위해 'SDLC에 보안 강화를 위한 프로세스를 포함한 것'
  -- 소프트웨어 개발 생명주기 (SDLC, Software Development Life Cycle)
     - 소프트웨어 개발 방법론의 바탕이 되는 것
     - 소프트웨어를 개발하기 위해 정의하고, 운용, 유지보수 등의 전 과정을 각 단계별로 나눈 것
- 요구사항 분석, 설계, 구현, 테스트, 유지보수 등 SDLC 전체 단계에 걸쳐 수행되어야 할 보안 활동을 제시함

** Secure SDLC의 대표적인 방법론
1) CLASP : SDLC의 '초기 단계'에서 '보안을 강화'하기 위해 개발된 방법론
2) SDL : 마이크로소프트 사에서 '안전한 소프트웨어 개발'을 위해 '기존의 SDLC를 개선'한 방법론
3) Seven Touchpoints : 소프트웨어 보안의 '모범사례를 SDLC에 통합한 방법론'

* SDLC 단계별 보안 활동
1) 요구사항 분석 단계 : 보안 항목에 해당하는 요구사항을 식별하는 작업 수행
2) 설계 단계 : 식별된 보안 요구사항들을 소프트웨어 설계서에 반영하고, 보안 설계서를 작성
3) 구현 단계 : 표준 코딩 정의서 및 소프트웨어 개발 보안 가이드를 준수하며, 설계서에 따라 보안 요구사항들을 구현함
4) 테스트 단계 : 설계 단계에서 작성한 보안 설계서를 바탕으로 보안 사항들이 정확히 반영되고 동작하는지 점검
5) 유지보수 단계 : 이전 과정을 모두 수행하였음에도 발생할 수 있는 보안사고들을 식별함 / 사고 발생 시, 이를 해결하고 보안 패치를 실시함

* 소프트웨어 개발 보안 요소
1) 기밀성 (Confidentiality) : 시스템 내의 정보와 자원은 '인가된 사용자에게만 접근 허용' / 정보가 전송 중에 노출되더라도 데이터를 읽을 수 없음
2) 무결성 (Integrity) : 시스템 내의 정보는 오직 '인가된 사용자만 수정'할 수 있음
3) 가용성 (Availability) : 인가받은 사용자는 시스템 내의 '정보와 자원을 언제라도 사용'할 수 있음
4) 인증 (Authentication) : 시스템 내의 정보와 자원을 사용하려는 사용자가 합법적인 사용자인지를 확인하는 모든 행위 / 대표적 방법 : 패스워드, 인증용 카드, 지문 검사 등
5) 부인 방지 (NonRepudiation) : 데이터를 송수신한 자가 송수신 사실을 부인할 수 없도록 송수신 증거를 제공

* 시큐어 코딩 (Secure Coding)
- '구현 단계' 에서 발생할 수 있는 보안 취약점들을 최소화하기 위해 '보안 요소들을 고려하여 코딩하는 것'
- 보안 취약점을 사전 대응하여 '안정성' 과 '신뢰성'을 확보
- 보안 정책을 바탕으로 시큐어 코딩 가이드를 작성하고, 개발 참여자에게는 시큐어 코딩 교육을 실시

# 02. 세션 통제

* 세션 통제
- '세션의 연결과 연결로 인해 발생하는 정보를 관리하는 것'
- 소프트웨어 개발 과정 중, '요구사항 분석 및 설계 단계' 에서 진단해야 하는 보안 점검 내용

** 세션 통제의 보안 약점
- 불충분한 세션 관리 : 일정한 규칙이 존재하는 '세션ID' 가 발급되거나, 타임아웃이 너무 길게 설정되어 있는 경우 발생하는 보안 약점
- 잘못된 세션에 의한 정보 노출 : '다중 스레드(Multi-Thread)' 환경에서 맴버 변수에 정보를 저장할 때 발생하는 보안 약점

*** 세션ID (Session ID) : 서버가 클라이언트들을 구분하기 위해 부여하는 키(Key)로, 클라이언트가 서버에 요청을 보낼 때마다 세션ID를 통해 인증이 수행됨

* 세션 설계 시 고려 사항
- 시스템의 모든 페이지에서 로그아웃이 가능하도록 'UI(User Interface)' 를 구성
- 로그아웃 요청 시, 할당된 세션이 완전히 제거되도록 함
- '세션 타임아웃' 은 중요도가 높으면 '2~5분' 낮으면 '15~30분' 으로 설정
- 이전 세션이 종료되지 않으면 새 세션이 생성되지 못하도록 설계
- 중복 로그인을 허용하지 않은 경우, 클라이언트의 중복 접근에 대한 세션 관리 정책을 수립함

* 세션 ID의 관리 방법
- 세션 ID는 안전한 서버에서 최소 '128비트의 길이' 로 생성
- 세션 ID의 예측이 불가능하도록 안전한 '난수 알고리즘' 을 적용
- 세션 ID가 노출되지 않도록 URL Rewrite 기능을 사용하지 않는 방향으로 설계
  -- URL Rewrite : 쿠키를 사용할 수 없는 환경에서 세선 ID 전달을 위해 URL에 세션 ID를 포함시키는 것
- 로그인 시 로그인 전의 세션 ID를 삭제하고 재할당
- 장기간 접속하고 있는 세션 ID는 주기적으로 지할당되도록 설계함


# 03. 입력 데이터 검증 및 표현

* 입력 데이터 검증 및 표현
- 입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목들

** 입력 데이터 검증 및 표현의 보안 약점
1) SQL 삽입 (Injection)
- 웹 응용 프로그램에 'SQL'을 삽입하여 내부 데이터베이스(DB) 서버의 데이터를 유출 및 변조하고, 관리자 인증을 우회하는 보안 약점
- '동적 쿼리' 에 사용되는 입력 데이터에 '예약어' 및 '특수문자' 가 입력되지 않게 필터링 되도록 설정하여 방지할 수 있음

2) 경로 조작 및 자원 삽입
- 데이터 입출력 경로를 조작하여 서버 자원을 수정, 삭제할 수 있는 보안 약점
- 사용자 입력값을 식별자로 사용하는 경우, '경로 순회 공격'을 막는 필터를 사용하여 방지할 수 있음

3) 크로스사이트 스크립팅 (XSS)
- 웹 페이지에 악의적인 '스크립트' 를 삽입하여 방문자들의 정보를 탈취하거나, 비정상적인 기능 수행을 유발하는 보안 약점
- 'HTML 태그' 의 사용을 제한하거나 스크립트에 삽입되지 않도록 <,>,& 등의 문자를 다른 문자로 치환함으로써 방지할 수 있음

4) 운영체제 명령어 삽입
- 외부 입력값을 통해 시스템 명령어의 실행을 유도함으로써 권한을 탈취하거나 시스템 장애를 유발하는 보안 약점
- 웹 인터페이스를 통해 시스템 명령어가 전달되지 않도록 하고, 외부 입력값을 검증 없이 내부 명령어로 사용하지 않음으로써 방지할 수 있음

5) 위험한 형식 파일 업로드
- 악의적인 명령어가 포함된 스크립트 파일을 업로드함으로써 시스템에 손상을 주거나, 시스템을 제어할 수 있는 보안 약점
- 업로드 되는 파일의 확장자 제한, 파일명의 암호화, 웹사이트와 파일 서버의 경로 분리, 실행 속성을 제거하는 등의 방법으로 방지할 수 있음

6) 신뢰되지 않는 URL 주소로 자동접속 연결
- 입력 값으로 사이트 주소를 받는 경우, 이를 조작하여 방문자를 피싱 사이트로 유도하는 보안 약점
- 연결되는 외부 사이트의 주소를 화이트 리스트로 관리함으로써 방지할 수 있음

7) 메모리 버퍼 오버플로
- 연속된 메모리 공간을 사용하는 프로그램에서 할당된 메모리의 범위를 넘어선 위치에서 자료를 읽거나 쓰려고 할 때 발생하는 보안 취약점
- 메모리 버퍼를 사용할 경우 적절한 버퍼의 크기를 설정하고, 설정된 범위의 메모리 내에서 올바르게 읽거나 쓸 수 있도록 함으로써 방지할 수 있음


# 04. 보안 기능

* 보안 기능
- 소프트웨어 개발의 '구현 단계 '에서 코딩하는 기능인 인증, 접근 제어, 기밀성, 암호화 등을 올바르게 구현하기 위한 보안 점검 항모ㅗㄱ들

** 보안 기능의 보안 약점
1) 적절한 인증 없이 중요 기능 허용
- '보안 검사'를 우회하여 인증 과정 없이 중요한 정보 또는 기능에 접근 및 변경이 가능함
- 중요 정보나 기능을 수행하는 페이지에서는 '재인증 기능' 을 수행하도록 하여 방지할 수 있음

2) 부적절한 인가
- '접근 제어 기능' 이 없는 실행 경로를 통해 정보 또는 권한을 탈취할 수 있음
- 모든 실행 경로에 대해 '접근 제어 검사'를 수행하고, 사용자에게는 반드시 필요한 접근 권한을 부여하여 방지할 수 있음

3) 중요한 자원에 대한 잘못된 권한 설정
- 권한 설정이 잘못된 자원에 접근하여 해당 자원을 임의로 사용할 수 있음
- 소프트웨어 관리자만 자원들을 읽고 쓸 수 있도록 설정하고, 인가되지 않은 사용자의 중요 자원에 대한 접근 여부를 검사함으로써 방지할 수 있음

4) 취약한 암호화 알고리즘
- 암호화된 환경 설정 파일을 해독하여, 비밀번호 등의 중요 정보를 탈취할 수 있음
- 안전한 '암호화 알고리즘' 을 이용하고, 업무 관련 내용이나 개인 정보 등에 대해서는 IT 보안인증사무국이 안정성을 확인한 '암호 모듈'을 이용함으로써 방지할 수 있음

5) 중요정보 평문 저장 및 전송
- 암호화되지 않은 평문 데이터를 탈취하여 중요한 정보를 휙득할 수 있음
- 중요한 정보를 저장하거나 전송할 때는 반드시 암호화 과정을 거치도록 하고 'HTTPS' 또는 'SSL' 과 같은 보안 채널을 이용함으로써 방지할 수 있음

6) 하드코드된 암호화 키
- 암호화된 키도 '하드코드' 된 경우, 유출 시 '역계산' 또는 '무차별 대입 공격' 에 의해 탈취될 수 있음
- 상수 형태의 암호키를 사용하지 않고, 암호화 키 생성 모듈 또는 보안이 보장된 외부 공간을 이용함으로써 방지할 수 있음

*** 하드코드 : 데이터를 코드 내부에 직접 입력하여 프로그래밍하는 방식
*** HTTPS(Hypertext Transfer Protocol Secure) : 웹브라우저와 서버 간의 안전한 통신을 위해 HTTP와 암호 통신규약을 결합한 것
*** SSL(Secure Sockets Layer) : 데이터를 송수신하는 두 컴퓨터 사이에 위치하여 인증, 암호화, 무결성을 보장하는 업계 표준 프로토콜
*** 무차별 대입 공격 (Brute Force Attack) : 암호화된 문서의 암호키를 찾아내기 위해 적용 가능한 모든 값을 대입하여 공격하는 방식

# 05. 시간 및 상태

* 시간 및 상태
- 동시 수행을 지원하는 '병렬 처리 시스템' 이나 다수의 프로세스가 동작하는 환경에서 시간과 실행 상태를 관리하여 시스템이 원할하게 동작되도록 하기 위한 보안 점검 항목들

** 시간 및 상태의 보안 약점
1) TOCTOU 경쟁 조건
- '검사 시점(Time Of Check)' 과 '사용 시점(Time Of Use)' 을 고려하지 않고 코딩하는 경우 발생하는 보안 약점
- 코드 내 '동기화 구문'을 사용하여 해당 자원에는 한 번에 하나의 프로세스만 접근 가능하도록 구성함으로서 방지할 수 있음

2) 종료되지 않는 반복문 또는 재귀 함수
- '반복문' 이나 '재귀 함수' 에서 종료 조건을 정의하지 않았거나, 논리 구조상 종료될 수 없는 경우 발생하는 보안 약점
- 모든 반복문이나 재귀 함수의 수행 횟수를 제한하는 설정을 추가하거나, 종료 조건을 점검하여 반복 또는 호출의 종료 여부를 확인함으로써 방지할 수 있음

*** 경쟁 조건(Race Condition) : 2개 이상의 프로세스가 공용 자원을 휙득하기 위해 경재앟고 있는 상태를 의미, 여기에서는 '검사 시점(TOC)' 과 '사용 시점(TOU)' 의 차이로 발생하는 경쟁 조건을 가리킴
*** 동기화 구문 : 공유 자원에 대해 둘 이상의 프로세스가 접근하는 것을 막는 구문으로, 'Synchronized', 'Mutex' 등이 있음


# 06. 에러 처리

* 에러 처리
- 소프트웨어 실행 중 발생할 수 있는 오류들을 사전에 정의하여 오류로 인해 발생할 수 있는 문제들을 예방하기 위한 보안 점검 항목들
  -- 에러 처리 : 에러는 오류의 영문명이며, '예외 처리(Exception Handling)' 와 '에러(오류) 처리 (Trouble Shooting)' 는 동일한 의미로 사용됨

** 예외 처리의 보안 약점
1) 오류 메시지를 통한 정보 노출
- 오류 발생으로 '실행 환경', '사용자 정보', '대버깅 정보' 등 중요한 정보가 메시지를 통해 외부에 노출되는 보안 약점
- 가능한 한 내부에서만 처리되도록 하거나, 메시지를 출력할 경우 최소한의 정보 또는 사전에 준비된 메시지만 출력되도록 하여 방지할 수 있음

2) 오류 상황 대응 부재
- 소프트웨어 개발 중 에러 처리를 하지 않았거나, 미비로 인해 발생하는 보안 약점
- 오류가 발생할 수 있는 부분에 '에러 처리 구문'을 작성하고, '제어문'을 활용하여 오류가 악용되지 않도록 코딩함으로써 방지할 수 있음

3) 부적절한 예외 처리
- 함수의 반환값 또는 오류들을 세분화하여 처리하지 않고 광범위하게 묶어 한 번에 처리하거나, 누락된 예외가 존재할 때 발생하는 보안 약점
- 모든 함수의 반환값이 의도대로 출력되는지 확인하고, 세분화된 예외 처리를 수행함으로써 방지할 수 있음


# 07. 코드 오류

* 코드 오류
- 소프트웨어 '구현 단계' 에서 개발자들이 코딩 중 실수하기 쉬운 '형(Type) 변환, 자원 변환' 등의 오류를 예방하기 위한 보안 점검 항목들

** 코드 오류의 보안 약점
1) 널 포인터 (Null Pointer) 역참조
- '널 포인터' 가 가리키는 메모리의 위치에 값을 저장할 때 발생하는 보안 약점
- 포인터를 이용하기 전 '널 값'을 갖고 있는지 검사함으로써 방지할 수 있음

2) 부적절한 자원 해제
- 자원을 반환하는 코드를 누락하거나, 프로그램 오류로 할당된 자원을 반환하지 못했을 때 발생하는 보안 약점
- 프로그램 내에 '자원 반환 코드' 가 누락되었는지 확인하고, 오류로 인해 함수가 중간에 종료되었을 때 예외 처리에 관계 없이 자원이 반환되도록 코딩함으로써 방지할 수 있음

3) 해제된 자원 사용
- 이미 사용이 종료되어 반환된 메모리를 참조하는 경우 발생하는 보안 약점
- 반환된 메모리에 접근할 수 없도록 주소를 저장하고, 있는 포인터를 초기화함으로써 방지할 수 있음

4) 초기화되지 않은 변수 사용
- 변수 선언 후 값이 부여되지 않은 변수를 사용할 때 발생하는 보안 약점
- 변수 선언 시 할당된 메모리를 초기화함으로써 방지할 수 있음

*** '널 포인터 역참조'로 오류가 발생하는 경우, "메모리 0x00000000 을 참조하였습니다." 라는 오류 메시지가 발생함

* 스택 가드 (Stack Guard)
- '널 포인터 역참조' 와 같이 '주소가 저장되는 스택에서 발생하는 보안 약점을 막는 기술' 중 하나
- 메모리 상에서 프로그램의 '복귀 주소' 와 '변수' 사이에 특정 값을 저장한 후 그 값이 변경되었을 경우, '오버플로우' 상태로 판단하여 프로그램 실행을 중단함으로써 잘못된 복귀 주소의 호출을 막음


# 08. 캡슐화

* 캡슐화 (Encapsulation)
- '정보 은닉' 이 필요한 중요한 데이터와 기능을 불완전하게 캡슐화 하거나 잘못 사용함으로써 발생할 수 있는 문제를 예방하기 위한 보안 점검항목들

** 캡슐화의 보안 약점
1) 잘못된 세션에 의한 정보 노출
- '다중 스레드(Multi-Thread)' 환경에서 '맴버 변수'에 정보를 저장할 때 발생하는 보안 약점
- '맴버 변수' 보다 '지역 변수' 를 활용하여 변수의 범위를 제한함으로써 방지할 수 있음

2) 제거되지 않고 남은 디버그 코드
- 개발 중 버그 수정이나 결과값 확인을 위해 남겨둔 코드로 인해 발생하는 보안 약점
- 소프트웨어 배포 전에 코드 검사를 수행하여 남아있는 '디버그 코드' 를 삭제함으로써 방지할 수 있음

3) 시스템 데이터 정보 노출
- 시스템의 내부 정보를 시스템 메세지 등을 통해 외부로 출력하도록 코딩했을 때 발생하는 보안 약점
- 노출되는 메시지에는 최소한의 정보만을 제공함으로써 방지할 수 있음

4) Public 메소드로 부터 반환된 Private 배열
- 선언된 클래스 내에서만 접근이 가능한 'Private 배열' 을 모든 클래스에서 접근이 가능한 'Public 메소드' 에서 반환할 때 발생하는 보안 약점
- 'Private 배열' 을 별도의 '메소드' 를 통해 조작하거나, 동일한 형태의 복제본으로 반환받은 후 값을 전달하는 방식으로 방지할 수 있음

5) Private 배열에 Public 데이터 할당
- 'Private 배열'에 'Public' 으로 선언된 데이터 또는 메소드의 '파라미터'를 저장할 때 발생하는 보안 약점
- 'Public' 으로 선언된 데이터를 'Private 배열' 에 저장할 때 '레퍼런스' 가 아닌 값을 직접 저장함으로써 방지할 수 있음

** 레퍼런스(Reference) 를 전달 또는 할당한다는 것은 메모리의 위치를 공유한다는 의미

* 접근 제어자
- 프로그래밍 언어에서 특정 개체를 선언할 때 '외부로부터의 접근을 제한하기 위해 사용되는 예약어'

** 접근 제어자의 종류 (O : 접근 가능, X ; 접근 불가능)

접근 제어자 	클래스 내부	패키지 내부	하위 클래스	패키지 외부
1) Public	    	      O		     O		     O		       O
2) Protected	      O		     O		     O		       X
3) Default   	      O		     O		     X		       X
4) Private    	      O		     X		     X		       X


# 09. API 오용

* API 오용
- 소프트웨어 '구현 단계' 에서 'API'를 잘못 사용하거나 보안에 취약한 'API'를 사용하지 않도록 하기 위한 보안 점검 항목들

* API 오용의 보안 약점
1) DNS Lookup 에 의존한 보안 결정
- '도메인명'에 의존하여 인증이나 접근 통제 등 보안 결정을 내리는 경우 발생하는 보안 약점
- 'DNS 검색'을 통해 도메인 이름을 비교하지 않고, 'IP 주소'를 직접 입력하여 접근함으로서 방지할 수 있음

2) 취약한 API 사용
- 보안 문제로 사용 금지된 API를 사용하거나, 잘못된 방식으로 API를 사용했을 때 발생하는 보안 약점
- 보안 문제로 금지된 함수는 안전한 함수로 대체하고, 'API'의 메뉴얼을 참고하여 보안이 보장되는 '인터페이스' 를 사용함으로써 방지할 수 있음

** DNS(Domain Name System) : 숫자로 된 IP주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것을 '도메인 네임' 이라고 하며, 이러한 도메인 네임을 IP 주소로 바꿔주는 역할을 하는 것


# 10. 암호 알고리즘

* 암호 알고리즘
- 패스워드, 주민번호, 은행 계좌와 같은 '중요 정보를 보호하기 위해 평문을 암호화된 문장으로 만드는 절차 또는 방법'

* 개인키 암호화 (Private Key Encryption) 기법
- '동일한 키' 로 데이터를 '암호화' 하고 '복호화' 하는 암호화 기법
- '대칭 암호 기법' 또는 '단일키 암호화 기법' 이라고도 함
- 암호화/복호화 속도가 '빠르지만' 관리해야 할 키의 수가 '많음'

** 개인키 암호화 기법의 종류
1) 스트림 암호화 방식 : 평문과 동일한 길이의 스트림을 생성하여 '비트 단위'로 암호화 하는 방식 / 종류 : LFSR, RC4
2) 블록 암호화 방식 : 한 번에 하나의 데이터 블록을 암호화 하는 방식 / 종류 : DES, SEED, AES, ARIA

* 공개키 암호화 (Public Key Encryption) 기법
- 데이터를 '암호화' 할 때 사용하는 '공개키(Public Key)'는 사용자에게 '공개하고' '복호화' 할 때의 '비밀키(secret Key)' 는 관리자가 비밀리에 관리하는 암호화 기법
- '비대칭 암호 기법' 이라고도 함
- 관리해야 할 키의 수가 '적지만' , 암호화/복호화 속도가 '느림'
= 대표적으로는 'RSA(Rivest Shamir Adleman)' 기법이 있음

** 양방향 알고리즘의 종류
1) SEED
- 1999년 '한국인터넷진흥원(KISA)' 에서 개발한 '블록 암호화 알고리즘'
- 블록 크기는 '128비트' 이며, 키 길이에 따라 '128, 256' 으로 분류됨

2) ARIA (Academy, Research Institute, Agency)
- 2004년 '국가정보원' 과 '산학연합회' 가 개발한 '블록 암호화 알고리즘'

3) DES (Data Encryptions Standard)
- 1975년 미국 'NBS' 에서 발표한 '개인키 암호화 알고리즘'
- DES를 3번 적용하여 보안을 더욱 강화한 '3DES(Triple DES)' 도 있음

4) AES (Advanced Encryption Standard)
- 2001년 '미국 표준 기술 연구소(NIST)' 에서 발표한 '개인키 암호화 알고리즘'
- 'DES' 의 한계를 느낀 'NIST' 에서 공모한 후 발표

5) RSA (Rivest shamir Adleman)
- 1978년 'MIT'의 '라이베스트(Rivest)', '샤미르(Shamir)', '애들먼(Adelman)'에 의해 제안된 '공개키 암호화 알고리즘'
- 큰 숫자를 '소인수분해' 하기 어렵다는 것에 기반하여 만들어짐

* 해시 (Hash)
- '임의의 길이' 의 입력 데이터나 메시지를 '고정된' 길이의 값이나 키로 변환하는 것
- 해시 알고리즘을 '해시 함수' 라고 부르며, 해시 함수로 변환된 값이나 키를 '해시값' 또는 '해시키' 라고 부름
- 데이터의 '암호화', '무결성' 검증을 위해 사용될 뿐만 아니라 정보 보호의 다양한 분야에서 활용됨

* 해시 함수의 종류
1) SHA 시리즈
- 1993년 미국 '국가안보국(NSA)' 이 설계, 미국 '국립표준기술연구소(NIST)' 에 의해 발표됨
- 초기 개발된 'SHA-0' 이후 'SHA-1' 이 발표되었고, 다시 'SHA-2' 라고 불리는 'SHA-224, SHA-256, SHA-384, SHA-512' 가 발표됨

2) MD5 (Message Digest Algorithm5)
- 1991년 'R.Rivest' 가 'MD4' 를 대체하기 위해 고안한 암호화 해시 함수
- 블록 크기가 '512비트' 이며, 키 길이는 '128비트' 임

3) N-NASH
- 1989년 일본의 '전선전화주식회사(NTT)' 에서 발표한 암호화 해시 함수
- 블록 크기와 키 길이가 모두 '128비트' 임

4) SNEFRU
- 1990년 'R.C.Merkle'가 발표한 해시 함수
- 32비트 프로세서에서 구현을 용이하게 할 목적으로 개발됨


# 11. 서비스 공격 유형

* 서비스 거부(DoS, Denial of Service) 공격
- 표적이 되는 서버의 자원을 고갈시킬 목적으로 다수의 공격자 또는 시스템에서 '대량의 데이터를 한 곳의 서버에 집중적으로 전송함으로써, 표적이 되는 서버의 정상적인 기능을 방해하는 것'

* 주요 서비스 거부 공격의 유형
1) Ping of Death (죽음의 핑)
- Ping 명령을 전송할 때 '패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송' 하여 공격 대상의 '네트워크를 마비시키는 서비스 거부 공격 방법'
- 공격에 사용되는 큰 패킷은 수백 개의 패킷으로 '분할' 되어 전송되는데, 공격 대상은 분할된 대량의 패킷을 수신함으로써 분할되어 전송된 패킷을 재조립해야 하는 부담과 분할되어
  전송된 각각의 패킷들의 'ICMP Ping 메시지'에 대한 응답을 처리하느라 시스템이 다운되게 됨

2) SMURFING (스머핑)
- 'IP나 'ICMP'의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만드는 공격 방법'
- 공격자는 '송신 주소'를 공격 대상지의 IP주소로 위장하고 해당 네트워크 라우터의 '브로드캐스트 주소' 를 수신지로 하여 패킷을 전송하면, 라우터의 브로드캐스트 주소로 수신도니 패킷은 해당 네트워크 내모든 컴퓨터로 전송됨
- 스머핑 공격을 무력화하는 방법 중 하나는, 각 네트워크 라우터에서 '브로드캐스트' 주소를 사용할 수 없게 미리 설정해 놓는 것

3) SYN Flooding
- 'TCP(Transmission Control Protocol)' 는 신뢰성 있는 전송을 위해 '3-Way-Handshake' 를 거친 후에 데이터를 전송하게 되는데, 
   'SYN Flooding'은 공격자가 가상의 클라이언트로 위장하여 '3-Way-Handshake 과정을 의도적으로 중단시킴으로써 공격 대상지인 서버가 대기 상태에 놓여 정상적인 서비스를 수행하지 못하게 하는 공격 방법' 임
- SYN Flooding에 대비하기 위해 수신지의 'SYN' 수신 대기 시간을 줄이거나 '침입 차단 시스템' 을 활용

4) TearDrop
- 데이터의 송수신 과정에서 패킷의 크기가 커 여러 개로 분할되어 전송 때 분할 순서를 알 수 있도록 'Fragment Offset' 값을 함께 전송하는데, 
  'TearDrop'은 이 'Offset 값을 변경시켜 수신 측에서 패킷을 재조립할 때 오류로 인한 과부하를 발생시킴으로써 시스템이 다운되도록 하는 공격 방법'
- TaerDrop에 대비하기 위해 'Fragment Offset'이 잘못된 경우 해당 패킷을 폐기하도록 설정함

5) LAND Attack (Local Area Network Denial Attack)
- '패킷을 전송할 때 송신 IP 주소와 수신 IP 주소를 모두 공격 대상의 IP 주소로 하여' 공격 대상에게 전송하는 것으로,
  이 패킷을 받은 공격 대상은 송신 IP 주소가 자신이므로 자신에게 응답을 수행하게 되는데, 이러한 패킷이 계속해서 전송될 경우 '자신에 대해 무한히 응답하게 하는 공격'
- 'LAND Attack'에 대비하기 위해 '송신 IP 주소' 와 '수신 IP 주소' 의 적절성을 검사

6) DDos 공격 (Distributed Denial of Service, 분산 서비스 거부 공격)
- '여러 곳에 분산된 공격 지점에서 한 곳의 서버에 대해 분산 서비스 공격을 수행하는 것'
- 네트워크에서 취약점이 있는 호스트들을 탐색한 후, 이들 호스트들에 분산 서비스 공격용 '툴' 을 설치하여 '에이전트(Agent)' 로 만든 후 'DDos 공격' 에 이용
  -- 분산 서비스 공격용 툴 : 에이전트(Agent)의 역할을 수행하도록 설계된 프로그램으로 '데몬(Daemon)' 이라고 부름


# 12. 서버 인증

* 보안 서버
- 인터넷을 통해 '개인정보를 암호화하여 송수신할 수 있는 기능을 갖춘 서버'

** 보안 서버의 기능
- 서버에 'SSL(Secure Socket Layer) 인증서' 를 설치하여 전송 정보를 암호화하여 송수신하는 기능
- 서버에 암호화 응용 프로그램을 설치하고 전송 정보를 암호화하여 송수신하는 기능

* 인증 (Authentication)
- 다중 사용자 컴퓨터 시스템이나 네트워크 시스템에서 '로그인을 요청한 사용자의 정보를 확인하고 접근 권한을 검증하는 보안 절차'
- 네트워크를 통해 컴퓨터에 접속하는 사용자의 등록 여부를 확인하는 것과, 전송된 메시지의 위,변조 여부를 확인하는 것이 있음

** 인증의 주요 유형
1) 지식 기반 인증 (Something You Know)
- '사용자가 기억하고 있는 정보를 기반으로 인증을 수행하는 것'
- 사용자의 기억을 기반으로 하므로 관리 비용이 저렴함
- 사용자가 인증 정보를 기억하지 못하면 본인이라도 인증 받지 못함

** 지식 기반 인증 유형
- 고정된 패스워드 (Password) : 사용자가 알고 있는 비밀번호를 접속할 때마다 반복해서 입력
- 패스 프레이즈 (Passphrase) : 일반 패스워드보다 길이가 길고 기억하기 쉬운 문장을 활용하여 비밀번호를 구성하는 방법
- 아이핀 (i-PIN) : 인터넷에서 주민등록번호 대신 쓸 수 있도록 만든 사이버 주민등록번호 / 사용자에 대한 신원확인을 완료한 후에 본인 확인 기관에서 온라인으로 발행함

2) 소유 기반 인증 (Something You Have)
- '사용자가 소유하고 있는 것을 기반으로 인증을 수행하는 것'
- 소유물이 쉽게 도용될 수 있으므로, '지식 기반 인증 방식' 이나 '생체 기반 인증 방식' 과 함께 사용

** 소유 기반 인증 유형
- 신분증 : 사용자의 사진이 포함된 주민등록증, 운전면허증, 여권 등을 사용하여 사용자의 신분 확인
- 메모리 카드(토큰) : 마그네틱 선에 '보안 코드'를 저장해서 사용하는 것으로, '카드 리더기' 를 통해서만 읽을 수 있음
- 스마트 카드 : '마이크로프로세서', '카드 운영체제', '메모리' 등으로 구성되어 사용자의 정보뿐만 아니라 특정 업무를 처리할 수 있는 기능이 내장되어 있음
- OTP (One Time Password) : 사용자가 패스워드를 요청할 때마다 '암호 알고리즘'을 통해 새롭게 생성된 패스워드를 사용하는 것 / 한 번 사용된 패스워드는 폐기됨

3) 생체 기반 인증 (Something You Are)
- '사용자의 고유한 생체 정보를 기반으로 인증을 수행하는 것'
- 사용이 쉽고, 도난의 위험도 적으며 위조가 어려움
- 생체 인증 대상 : 지문, 홍채/망막, 얼굴, 음성, 정맥 등

4) 위치 기반 인증 (Somewhere You Are)
- 인증을 시도하는 위치의 적절성 확인 / 에) 콜백, GPS나 IP 주소를 이용한 위치 기반 인증

5) 기타 인증 방법
- 행위 기반 인증 (Something You Do) : 사용자의 행동 정보를 이용해 인증 수행 / 예) 서명, 동작


# 13. 보안 아키텍쳐 / 보안 프레임워크

* 보안 아키텍처 (Security Architectur)
- 정보 시스템의 '기밀성(Confidentiality)', '무결성(Integrity)', '가용성(Availability)' 을 확보하기 위해 '보안 요소 및 보안 체계를 식별하고, 이들 간의 관계를 정의한 구조'
- 보안 아키텍처를 통해 '관리적', '물리적', '기술적 보안' 개념의 수립, 보안 관리 능력의 향상, 일관된 보안 수준의 유지를 기대할 수 있음
- 보안 수준에 변화가 생겨도 기본 보안 아키텍처의 수정 없이 지원이 가능해야 함
- 보안 요구사항의 변화나 추가를 수용할 수 있어야 함

* 보안 프레임워크 (Security Framework)
- 안전한 정보 시스템 환경을 유지하고 보안 수준을 향상시키기 위한 체계

** ISO 27001
- 정보 보안 관리를 위한 국제 표준으로, 일종의 보안 인증이자 가장 대표적인 보안 프레임워크
- 영국의 'BSI(British Standartds Institute)' 가 제정한 'BS 7799' 를 기반으로 구성되어 있음
- 조직에 대한 정보 보안 관리 규격이 정의되어 있어 실제 검사/인증용으로 사용됨






















































































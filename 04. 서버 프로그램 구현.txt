
# 01. 개발 환경 구축

* 개발 환경 구축
- 응용 소프트웨어 개발을 위해 '개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것'
- 개발 환경은 응용 소프트웨어가 운영될 환경과 유사한 구조로 구축함
- 분석 단계의 산출물을 바탕으로 개발에 필요한 하드웨어와 소프트웨어를 선정
- 하드웨어와 소프트웨어의 성능, 편의성, 라이선스 등 비즈니스 환경에 적합한 제품들을 최종적으로 결정하여 구축

* 하드웨어 환경
- 사용자의 인터페이스 역할을 하는 '클라이언트(Client)' 그리고 클라이언트와 통신하여 서비스를 제공하는 '서버(Server)' 로 구성됨

** 클라이언트의 종류 : 개인용 컴퓨터(PC), 스마트폰 등

** 서버의 종류
1) 웹 서버 (Web Server) : 클라이언트로부터 직접 요청을 받아 처리함 / 저용량의 정적 파일들을 제공함
2) 웹 애플리케이션 서버 (WAS, Web Application Server) : 동적 서비스를 제공하거나, 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할을 수행함
3) 데이터베이스 서버 (DB Server) : 데이터베이스와 이를 관리하는 DBMS를 운영함
4) 파일 서버 (File Server) : 데이터베이스에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장함

* 소프트웨어 환경
- 클라이언트 서버 운영을 위한 '시스템 소프트웨어' 와 개발에 사용되는 '개발 소프트웨어' 로 구성됨

** 시스템 소프트웨어의 종류 : 운영체제(OS), 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS 등

** 개발 소프트웨어의 종류
1) 요구사항 관리 도구 : 요구사항 수집과 분석, 추적 등 편리하게 도와주는 소프트웨어
2) 설계 / 모델링 도구 : UML(통합 모델링 언어)을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 소프트웨어
3) 구현 도구 : 개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 SW
4) 빌드 도구 : 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 SW
5) 테스트 도구 : 모듈들이 요구사항에 적합하게 구현되었는지 테스트하는 SW
6) 형상 관리 도구 : 산출물들을 버전별로 관리하여 품질 향상을 지원하는 SW

* 웹 서버 (Web Server) 의 기능
1) HTTP/HTTPS 지원 : 브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜
2) 통신 기록 (Communication Log) : 처리한 요청들을 로그 파일로 기록하는 기능
3) 정적 파일 관리 (Managing Static Files) : HTML, CSS, 이미지 등 정적 파일들을 저장하고 관리하는 기능
4) 대역폭 제한 (Bandwidth Throttling) : 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능
5) 가상 호스팅 (Virtual Hosting) : 하나의 서버로 여러 개의 도메인 이름을 연결하는 기능
6) 인증 (Authentication) : 사용자가 합법적인 사용자인지를 확인하는 기능

* 개발 언어의 선정 기준
- 적정성 : 개발하려는 소프트웨어의 목적에 적합해야 함
- 효율성 : 코드의 작성 및 구현이 효율적이어야 함
- 이식성 : 다양한 시스템 및 환경에 적용이 가능해야 함
- 친밀성 : 개발 언어에 대한 개발자들의 이해도와 활용도가 높아야 함
- 범용성 : 다른 개발 사례가 존재하고 여러 분야에서 활용되고 있어야 함


# 02. 소프트웨어 아키텍쳐

* 소프트웨어 아키텍처
- '소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체'
- 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정함
- 소프트웨어 아키텍처 설계의 기본 원리에는 '모듈화', '추상화', '단계적 분해', '정보 은닉' 이 있음

* 모듈화 (Modularity)
- 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 '시스템의 기능을 모듈 단위로 나누는 것'
- 모듈의 크기를 너무 '작게' 나누면 개수가 '많아져' 모듈 간의 '통합 비용이 많이 듦'
- 모듈의 크기를 너무 '크게' 나누면 개수가 '적어' 통합 비용은 '적게' 들지만, '모듈 하나의 개발 비용이 많이 듦'

* 추상화 (Abstraction)
- 문제의 '전체적이고 포괄적인 개념을 설계한 후', 차례로 세분화하여 '구체화시켜 나가는 것'
- 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인들을 테스트할 수 있음

** 추상화의 유형
1) 과정 추상화 : 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
2) 데이터 추상화 : 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
3) 제어 추상화 : 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법

* 단계적 분해 (Stepwise Refinement)
- 문제를 '상위의 중요 개념으로부터 하위의 개념으로 구체화 시키는 분할 기법'
- Niklaus Wirth 에 의해 제안된 '하향식' 설계 전략
- 소프트웨어의 포괄적인 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행

* 정보 은닉 (Information Hiding)
- 한 '모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법'
- 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있음
- 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이

* 상위 설계와 하위 설계
- 상위 설계 : 아키텍처, 예비 설계 / 시스템의 전체적인 구조 / 구조, DB, 인터페이스
- 하위 설계 : 모듈, 상세 설계 / 시스템의 내부 구조 및 행위 / 컴포넌트, 자료 구조, 알고리즘

* 소프트웨어 아키텍처의 품질 속성
- 소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지 확인하기 위해 품질 평가 요소들을 구체화 시켜 놓은 것

** 품질 평가 요소의 종류
1) 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성 등
2) 비즈니스 측면 : 시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개 일정 등
3) 아키텍처 측면 : 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성 등

* 소프트웨어 아키텍처의 설계 과정
1) 설계 목표 설정 : 요구사항을 분석하여 전체 시스템의 설계 목표 설정
2) 시스템 타입 결정 : 시스템과 서브 시스템의 타입을 결정하고, 아키텍처 패턴 선택
3) 아키텍처 패턴 적용 : 시스템의 표준 아키텍처 설계
4) 서브 시스템 구체화 : 서브 시스템의 기능 및 서브 시스템 간의 상호작용을 위한 동작과 인터페이스 정의
5) 검토 : 설계 목표, 요구 사항, 설계의 기본 원리 등을 만족하는지 아키텍처 검토

* 협약 (Contract) 에 의한 설계
- '컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것'
- 컴포넌트에 대한 정확한 인터페이스를 명세함

** 명세에 포함될 조건
1) 선행 조건 (Precondition) : 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
2) 결과 조건 (Postcondition) : 오퍼레이션이 수행된 후 만족되어야 할 조건
3) 불변 조건 (Invariant) : 오퍼레이션이 실행되는 동안 항상 만족디어야 할 조건


# 03. 아키텍처 패턴

* 아키텍처 패턴 (Patterns)
- '아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제'
- 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시
- 아키텍처 패턴에는 서브 시스템들과 그 역할이 정의되어 있음
- 서브 시스템 사이의 관계와 여러 규칙, 지침 등이 포함되어 있음

** 아키텍처 패턴의 종류
1) 레이어 패턴 (Layers Pattern)
- '시스템을 계층으로 구분하여 구성하는' 고전적인 방법의 패턴
- 상위 계층은 하위 계층에 대한 '서비스 제공자'가 되고, 하위 계층은 상위 계층의 '클라이언트' 가 됨
- 서로 마주보는 2개의 계층 사이에서만 상호작용이 이루어짐
- 대표적으로 'OSI 참조 모델' 이 있음

2) 클라이언트 - 서버 패턴 (Client - Server Pattern)
- '하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴'
- 사용자 클라이언트를 통해 서버에 요청하면 클라이언트가 응답을 받아 사용자에게 제공하는 방식

3) 파이프 - 필터 패턴 (Pipe - Filter Pattern)
- '데이터 스트림 절차' 의 각 단계를 '필터로 캡슐화하여 파이프를 통해 전송하는 패턴'
- 앞 시스템의 처리 결과물을 '파이프'를 통해 전달받아 처리한 후, 그 결과물을 다시 파이프를 통해 다음 시스템으로 넘겨주는 패턴을 반복
- 데이터 변환, 버퍼링, 동기화 등에 주로 사용됨
- 대표적으로 UNIX의 '쉘(shell)' 이 있음

4) 모델 - 뷰 - 컨트롤러 패턴 (Model - View - Controller Pattern)
- '서브 시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴'
- '컨트롤러' 가 사용자의 요청을 받으면 핵심 기능과 데이터를 보관하는 '모델' 을 이용하여 '뷰'에 정보를 출력하는 구조
- 여러 개의 뷰를 만들 수 있음 / 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 '대화형 애플리케이션' 에 적합함

* 기타 패턴
1) 마스터-슬레이브 패턴 (Master-Slave Pattern)
- '슬레이브 컴포넌트' 에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴 / ex) 장애 허용 시스템, 병렬 컴퓨팅 시스템

2) 브로커 패턴 (Broker Pattern)
- 사용자가 원하는 서비스와 특성을 '브로커 컴포넌트' 에 요청하면 브로커 컴포넌트가 요청에 맞는 '컴포넌트'와 '연결지'를 연결해주는 패턴 / ex) 분산 환경 시스템

3) 피어-투-피어 패턴 (Peer-To-Peer Pattern)
- '피어(Peer)' 라 불리는 하나의 컴포넌트가 클라이언트가 될 수도, 서버가 될 수도 있는 패턴 / ex) 파일 공유 네트워크

4) 이벤트-버스 패턴 (Event-Bus Pettern)
- 소스가 특정 채널에 이벤트 메시지를 '발행(Publish)' 하면, 해당 채널을 '구독(Subscribe)' 한 '리스터(Listener)' 들이 메시지를 받아 이벤트 처리하는 패턴 / ex) 알림 서비스

5) 블랙보드 패턴 (Blackboard Pattern)
- 모든 컴포넌트들이 '공유 데이터 저장소' 와 '블랙보드 컴포넌트' 에 접근이 가능한 패턴 / ex) 음성 인식, 차량 식별, 신호 해석

6) 인터프리터 패턴 (Interpreter Pattern)
- 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴 / ex 번역기, 컴파일러, 인터프리터


# 04. 객체 지향 (Object-Oriented)

* 객체 지향
- 소프트웨어의 '각 요소들을 객체(Object) 로 만든 후, 객체들을 조립해서 소프트웨어를 개발하는 기법
- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있음
- 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고, 유지보수가 쉬움

** 객체지향의 구성 요소
1) 객체 (Obejct)
- '데이터'와 이를 처리하기 위한 '함수'를 묶어 놓은 소프트웨어 모듈
  -- 데이터 : 객체가 가지고 있는 정보로, 속성이나 상태, 분류 등 (변수, 상수, 자료 구조라고도 함)
  -- 함수 : 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘 / 객체의 상태를 참조하거나 변경하는 수단 (메소드, 서비스, 동작, 연산이라고도 함)

2) 클래스 (Class)
- 공통된 '속성'과 '연산'을 갖는 객체의 집합
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
- 클래스에 속한 각각의 객체를 '인스턴스(Instance)' 라고 함

3) 메시지 (Message)
- '객체들 간의 상호작용에 사용되는 수단으로, 객체의 동작이나 연산을 일으키는 외부의 요구사항'
- 메시지를 받은 객체는 대응하는 연산을 수행하여 예상된 결과를 반환함

** 객체 지향의 특징
1) 캡슐화 (Encapsulation)
- '외부에서 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것'
- 캡슐화된 객체는 외부 모듈의 변경으로 인한 파급 효과가 '적음'
- 객체들 간에 메시지를 주고 받을 때, 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 '단순해지고', 객체 간의 결합도가 '낮아짐'

2) 상속 (Inheritance)
- '상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것'
- '하위 클래스' 는 물려받은 속성과 연산을 다시 정의하지 않아도 즉시 자신의 속성으로 사용할 수 있음
- '하위 클래스' 는 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있음

3) 다형성 (Polymorphism)
- '하나의 메시지에 대해 각각의 객체가' 가지고 있는 '고유한 방법으로 응답할 수 있는 능력'
- 객체들은 동일한 메소드명을 사용하며, 같은 의미의 응답을 함 ex) '+' 연산자의 경우, 숫자 클래스에서는 덧셈, 문자 클래스에서는 문자열의 연결 기능으로 사용됨

4) 연관성 (Relationship)
- '두 개 이상의 객체들이 상호 참조하는 관계'

** 연관성의 종류
- is member of : 연관화 (Association) : 2개 이상의 객체가 상호 관련되어 있음을 의미
- is instance of : 분류화 (Classification) : 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것
- is part of : 집단화 (Aggregation) : 관련 있는 객체들을 묶어 하나의 '상위 객체'를 구성하는 것
- is a : 일반화 (Generalization) : 공통적인 성질들로 추상화한 '상위 객체'를 구성하는 것
       : 특수화/상세화 (Specialization) : 상위 객체를 구체화하여 '하위 객체'를 구성하는 것


# 05. 객체 지향 분석 및 설계

* 객체 지향 분석 (OOA, Object oriented Analysis)
- '사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업'
- 개발을 위한 업무를 '객체' 와 '속성', '클래스' 와 '맴버', '전체' 와 '부분' 등으로 나누어서 분석함
- '클래스'를 식별하는 것이 객체 지향 분석의 주요 목적

* 객체 지향 분석의 방법론
1) Rumbaugh (럼바우) 방법 : 분석 활동을 '객체 모델', '동적 모델', '기능 모델' 로 나누어 수행
2) Booch (부치) 방법 : '미시적(Micro)' 개발 프로세스와 '거시적(Macro)' 개발 프로세스를 모두 사용 / 클래스오 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
3) Jacobson 방법 : '유스케이스(Use Case)' 를 강조하여 사용
4) Coad와 Yourdon 방법 : 'E-R 다이어그램' 을 사용하여 객체의 행위를 모델링함 / 객체 식별, 구조 식별, 주체 정의, 속성 과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성함
5) Wirfs-Brock 방법 : 분석과 설계 간의 구분이 없고, '고객 명세서' 를 평가해서 설계 작업까지 연속적으로 수행함

* 럼바우 (Rumbaugh)의 분석 기법
- '모든 소프트웨어 구성 요소를 "그래픽 표기법" 을 이용하여 모델링하는 기법'
- '객체 모델링 기법(OMT, Object Modeling Technique)' 이라고도 함
- 분석 활동은 '객체 모델링 => 동적 모델링 => 기능 모델링' 순으로 이루어 짐
  -- 객체 모델링 (Object Modeling) : '정보 모델링' 이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 '객체 다이어그램' 으로 표시하는 것
  -- 동적 모델링 (Dynamic Modeling) : '상태 다이어그램' 을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
  -- 기능 모델링 (Function Modeling) : '자료 흐름도(DFD)' 를 이용하여 다수의 프로세스들 간 자료 흐름을 중심으로 처리 과정을 표현한 모델링

* 객체 지향 설계 원칙
- '변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 원칙'
- SRP, OCP, LSP, ISP, DIP 의 다섯 가지 원칙의 앞 글자를 따 'SOLID 원칙' 이라고 부름

** 종류
1) 단일 책임 원칙 (SRP) : 객체는 단 하나의 책임만 가져야 한다는 원칙
2) 개방-폐쇄 원칙 (OCP) : 기존의 코드를 변경하지 않고, 기능을 추가할 수 있도록 설계해야 한다는 원칙
3) 리스코프 치환 원칙 (LSP) : 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다는 원칙
4) 인터페이스 분리 법칙 (ISP) : 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙
5) 의존 역전 원칙 (DIP) : 의존 관계 성립 시, '추상성' 이 높은 클래스와 의존 관계를 맺어야 한다는 원칙


# 06. 모듈

* 모듈 (Module)
- '모듈화' 를 통해 분리된 시스템 각 기능으로, 서브루틴, 서브 시스템, 소프트웨어 내의 프로그램, 작업 단위 등을 의미
- 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립적임을 의미
- 모듈의 독립성은 '결합도(Coupling)' 와 '응집도(Cohesion)' 에 의해 측정됨

* 모듈의 독립성
- 모듈의 독립성은 모듈이 다른 모듈과의 과도한 상호작용 배제하고, '하나의 기능만을 수행함' 으로써 이루어짐
- 독립성을 높이려면 모듈의 '결합도'는 약하게, '응집도' 는 강하게, 모듈의 '크기'는 작게 만들어야 함

* 결합도 (Coupling)
- '모듈 간에 상호 의존하는 정도' 또는 두 모듈 사이의 연관 관계
- 결합도가 '약할수록' 품질이 '높고', '강할수록' 품질이 낮음

** 결합도의 종류
1) 내용 결합도 (Content Coupling) : 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
2) 공통(공유) 결합도 (Common Coupling) : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
3) 외부 결합도 (External Coupling) : 어떤 모듈에서 선언한 데이터(변수) 를 외부의 다른 모듈에서 참조할 때의 결합도
4) 제어 결합도 (Control Coupling) : 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도
			        하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 '권리 전도 현상' 이 발생하게 됨
5) 스탬프(검인) 결합도 (Stamp Coupling) : 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도
6) 자료 결합도 (Data Coupling) : 모듈 간의 인터페이스가 '자료 요소'로만 구성될 때의 결합도

* 응집도 (Cohesion)
- '모듈의 내부 요소들이 서로 연관되어 있는 정도'
- 응집도가 '강할수록' 품질이 '높고', '약할수록' 품질이 '낮음'

** 응집도의 종류
1) 기능적 응집도 (Functional Cohesion) : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
2) 순차적 응집도 (Sequential Cohesion) : 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
3) 교환(통신)적 응집도 (Communication Cohesion) : 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
4) 절차적 응집도 (Procedural Cohesion) : 모듈이 다수의 관련 기능을 가질 때, 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
5) 시간적 응집도 (Temporal Cohesion) : 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
6) 논리적 응집도 (Logical Cohesion) : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
7) 우연적 응집도 (Coincidental Cohesion) : 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도

* 팬인 (Fan-In) / 팬아웃 (Fan-Out)
- 팬인 (Fan-In) : '어떤 모듈을 제어하는 모듈의 수'
- 팬아웃 (Fan-Out) : '어떤 모듈에 의해 제어되는 모듈의 수'
- 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있다고 볼 수 있음
- 팬인이 높은 경우, '단일 장애점' 이 발생할 수 있으므로 중점적인 관리 및 테스트가 필요
  -- 단일 장애점 (SPOF, Single Point Of Failure) : 시스템의 구성 요소 중 동작하지 않으면 전체 시스템이 중단되어 버리는 요소를 의미하며, '단일 실패점' 이라고도 함

* N-S 차트 (Nassi-Schneiderman Chart)
- '논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법'
- '박스 다이어그램', 'Chapin Chart' 라고도 함
- 'GOTO' 나 '화살표' 를 사용하지 않음
- '연속', '선택 및 다중 선택', '반복' 의 3가지 제어 논리 구조로 표현함
- 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합


# 07. 단위 모듈

* 단위 모듈 (Unit Module)
- 소프트웨어 구현에 필요한 여러 동작 중, '한 가지 동작을 수행하는 기능을 모듈로 구현한 것'
- 단위 모듈로 구현되는 하나의 기능을 '단위 기능' 이라고 부름
- 독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입되기도 함

** 구현 과정
1) 단위 기능 명세서 작성 : 기능 및 코드 명세서나 설계 지침과 같은 단위 기능을 명세화하는 단계
2) 입,출력 기능 구현 : 입출력 기능을 위한 알고리즘 및 데이터를 구현하는 단계
3) 알고리즘 구현 : 단위 기능별로 모듈을 구현하는 단계

* IPC (Inter-Process Communication)
- '모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합'
- 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능

** IPC의 대표 메소드 5가지
1) Shared Memory : 공유 가능한 메모리를 구성하여 다수의 프로세스가 통신하는 방식
2) Socket : 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스 간에 통신하는 방식
3) Semaphores : 공유 자원에 대한 접근 제어를 통해 통신하는 방식
4) Pipes & Named Pipes : 'Pipe' 라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신하는 방식
		         Pipe는 하나의 프로세스가 이용 중이라면 다른 프로세스는 접근할 수 없음
5) Message Queusing : 메시지가 발생하면 이를 전달하는 방식으로 통신하는 방식

* 단위 모듈 테스트
- 프로그램의 단위 기능으로 구현된 '모듈이 정해진 기능을 정확히 수행하는지 검증하는 것'
- '단위 테스트(Unit Test)' 라고도 불림
- 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로, 시스템 수준의 오류는 잡아낼 수 없음

* 테스트 케이스 (Test Case)
- 구현된 '소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서'
- 테스트 케이스를 이용하지 않은 테스트는 특정 요소에 대한 검증이 누락되거나 불필요한 검증의 반복으로 인해 인력과 시간을 낭비할 수 있음

** ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스의 구성 요소
1) 식별자 (Identifier) : 항목 식별자, 일련번호
2) 테스트 항목 (Test Item) : 테스트 대상 (모듈 또는 기능)
3) 입력 명세 (Input Specification) : 입력 데이터 또는 테스트 조건
4) 출력 명세 (Output Specification) : 테스트 케이스 수행 시 예상되는 출력 결과
5) 환경 설정 (Environmental Needs) : 필요한 하드웨어나 소프트웨어의 환경
6) 특수 절차 요구(Special Procedure Requirement) : 테스트 케이스 수행 시 특별히 요구되는 절차
7) 의존성 기술 (Inter-case Dependencies) : 테스트 케이스 간의 의존성


# 08. 공통 모듈

* 공통 모듈
- '여러 프로그램에서 공통으로 사용할 수 있는 모듈'
- '자주 사용되는 계산식' 이나 '매번 필요한 사용자 인증' 과 같은 기능들이 공통 모듈로 구성될 수 있음
- 공통 모듈을 구현할 때는 해당 기능을 명확히 이해할 수 있도록 명세 기법을 준수해야 함

* 공통 모듈 명세 기법의 종류
1) 정확성 (Correctness) : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성
2) 명확성 (Clarity) : 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성
3) 완전성 (Completeness) : 시스템 구현을 위해 필요한 모든 것을 기술
4) 일관성 (Consistency) : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성
5) 추적성 (Traceability) : 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성

* 재사용 (Reuse)
- '이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화하는 작업'
- 새로 개발하는데 필요한 비용과 시간을 절약할 수 있음
- 누구나 이해할 수 있고, 사용이 가능하도록 사용법을 공개해야 함

** 재사용 규모에 따른 분류
1) 함수와 객체 : 클래스나 메소드 단위의 소스 코드를 재사용함
2) 컴포넌트 : 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용함
3) 애플리케이션 : 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용함

* 효과적인 모듈 설계 방안
- '결합도'는 줄이고, '응집도' 는 높여 모듈의 '독립성' 과 '재사용'을 높임
- '복잡도'와 '중복성' 을 줄이고, '일관성'을 유지시킴
- 모듈의 기능은 예측이 가능해야 하며, 지나치게 제한적이어서는 안됨
- 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해
- 효과적인 제어를 위해 모듈 간의 계층적 관계를 정의하는 자료가 제시되어야 함


# 09. 코드

* 코드 (Code)
- '자료의 분류, 조합, 집계, 추출을 용이하게 하기 위해 사용하는 기호'
- 정보를 신속, 정확, 명료하게 전달할 수 있게 함
- 일정한 규칙에 따라 작성됨
- 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미침

** 코드의 주요 기능
1) 식별 기능 : 데이터 간의 성격에 따라 구분이 가능
2) 분류 기능 : 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화 할 수 있음
3) 배열 기능 : 의미를 부여하여 나열할 수 있음
4) 표준화 기능 : 다양한 데이터를 기준에 맞추어 표현할 수 있음
5) 간소화 기능 : 복잡한 데이터를 간소화 할 수 있음

*** 코드의 종류
1) 순차 코드 (Sequence Code)
- 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법
- '순서 코드' 또는 '일련번호 코드' 라고도 함
ex) 1, 2, 3, 4.....

2) 블록 코드 (Block Code)
- 코드화 대상 항목 중에서 공통성이 있는 것끼지 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법
- '구분 코드' 라고도 함
ex) 1001 ~ 1100 : 총무부, 1101 ~ 1200 : 영업부..

3) 10진 코드 (Decimal Code)
- 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한만큼 반복하는 방법
- '도서 분류식 코드' 라고도 함
ex) 1000 : 공학, 1100 : 소프트웨어 공학, 1110 : 소프트웨어 설계

4) 그룹 분류 코드 (Group Classification Code)
- 코드화 대상 항목을 일정 기준에 따라 대, 중, 소 분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법
ex) 1-01-001 : 본사-총무부-인사계, 2-01-001 : 지사-총무부-인사계

5) 연상 코드 (Mnemonic Code)
- 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법
ex) TV-40 : 40인치 TV, L-15-220 : 15W 220V의 램프

6) 표의 숫자 코드 (Significant Digit Code)
- 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용 시키는 방법
- '유효 숫자 코드' 라고도 함
ex) 120-720-1500 : 두께x폭x길이가 120, 720, 1500 인 강판

7) 합성 코드 (Combined Code)
- 필요한 기능을 하나의 코드로 수행하기 어려운 경우, 2개 이상의 코드를 조합하여 만드는 방법
ex) 연상 코드 + 순차 코드 - KE-711 : 대한항공 711기, AC-253 : 에어캐나다 253기


# 10. 디자인 패턴


# 11. 개발 지원 도구

* 통합 개발 환경 (IDE, Integrated Development Environment)
- 개발에 필요한 환경, '편집기(Editor), 컴파일러(Compiler), 디버거(Debugger)' 등 다양한 툴을 하나의 인터페이스로 통합하여 제공하는 환경
- '통합 개발 환경 도구' 는 통합 개발 환경을 제공하는 소프트웨어를 의미
- 코드를 실행하거나 테스트할 때 오류가 발생한 부분을 시각화하므로 수정이 용이

** 통합 개발 환경 도구의 종류
1) 이클립스 (Eclipse) : Eclipse Foundation IBM - 크로스 플랫폼 - Windows, Linux, MacOS 등 - Java, C, C++, PHP, JSP 등
2) 비주얼 스튜디오 (Visual Studio) : Microsoft - Win32, Win64 - Windows, MacOS - Basic, C, C++, C#, .NET 등
3) 엑스 코드 (Xcode) : Apple - Mac, IPhone - MacOS, IOS - C, C++, C#, Java, AppleScript 등
4) 안드로이드 스튜디오 (Android Studio) : Google - Android - Windows, Linux, MacOS - Java, C, C++
5) IDEA : JetBrains(이전 InteiJ) - 크로스 플랫폼 - Windows, Linux, MacOS - Java, JSP, XML, Go, Kotlin PHP 등

* 빌드 도구
- 빌드 : '소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물
- 빌드 도구는 '전처리(Preprocessing), 컴파일(Compile)' 등의 작업을 수행함
  -- 전처리(Preprocessing) : 컴파일에 앞서 코드에 삽입된 주석을 제거하거나 매크로들을 처리하는 과정

** 대표적인 빌드 도구
1) Ant (Another Neat Tool) : 아파치 소프트웨어 재단에서 개발 / 자바 프로젝트의 공식적인 빌드 도구 / 정해진 규칙이나 표준이 없음
2) Maven : 아파치 소프트웨어 재단에서 Ant 대안으로 개발 / '의존성(Dependency)' 을 설정하여 라이브러리를 관리 / 규칙이나 표준이 존재하여 예외 사항만 기록
3) Gradle : '한스 도커(Hans Dockter)가 Ant와 Maven을 보완하여 개발 / 안드로이드 스튜디오의 공식 빌드 도구 / '그루비(Groovy)' 기반의 빌드 스크립트를 사용

*** 그루비 (Groovy) : 자바를 기반으로 여러 프로그래밍 언어들의 장점을 모아 만든 '동적 객체지향 프로그래밍'

* 기타 협업 도구
- 협업 도구 : '개발에 참여하는 사람들이 서로 다른 작업 환경에서 원할히 프로젝트를 수행할 수 있도록 도와주는 도구'
- '협업 소프트웨어, 그룹웨어(Groupware)' 등으로 불림
- 일정 관리, 업무흐름 관리, 정보 공유, 커뮤니케이션 등의 업무 보조 도구가 포함됨


# 12. 서버 개발

* 서버 개발
- '웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작하여 웹 애플리케이셔 서버(WAS) 에 탑재하는 것'
- 서버 개발에 사용되는 프로그래밍 언어에는 Java, JavaScript, Python, PHP, Rudy 등이 있음
- 각 프로그래밍 언어에는 해당 언어로 서버 프로그램을 개발할 수 있도록 지원하는 '프레임워크' 가 있음

* 서버 개발 프레임워크
- 서버 프로그램 개발 시 '다양한 네트워크 설정, 요청 및 응답 처리, 아키텍처 모델 구현 등 손쉽게 처리할 수 있도록 클래스나 인터페이스를 제공하는 소프트웨어' 를 의미
- 서버 개발 프레임워크의 대부분은 '모델-뷰-컨트롤러(MVC) 패턴' 을 기반으로 개발됨

** 서버 개발 프레임워크 종류
1) Spring : Java 기반으로 만든 프레임워크 / 전자정부 표준 프레임워크의 기반 기술로 사용되고 있음
2) Node.js : JavaScript를 기반으로 만든 프레임워크 / 비동기 입출력 처리와 이벤트 위주의 높은 처리 성능을 갖고 있어 실시간으로 입출력이 빈번한 애플리케이션에 적합함
3) Django : Python을 기반으로 만든 프레임워크 / 컴포넌트의 재사용과 플러그인화를 강조하여 신속한 개발이 가능하도록 지원함
4) Codeigniter : PHP 기반으로 만든 프레임워크 / 인터페이스가 간편하여 서버 자원을 적게 사용함
5) Rudy on Rails : Rudy를 기반으로 만든 프레임워크 / 테스트를 위한 웹 서버를 지원하며 데이터베이스 작업을 단순화, 자동화시켜 개발 코드의 길이가 짧아지게함으로써 신속한 개발이 가능함

* 서버 개발 과정
- 서버 개발 과정은 'DTO/VO, SQL, DAO, Service,  Controller' 를 각각 구현하는 과정
  -- DTO (Dtat Transfer Object) : 데이터의 교환을 위해 생성되는 객체
  -- VO (Value Object) : DTO와 동일하지만 읽기만 가능한 객체, 변경이 불가능함
  -- DAO (Data Access Object) : 데이터베이스에 접근하여 데이터를 조회, 생성, 수정, 삭제 작업을 수행하는 객체
- 구현 순서는 개발자가 임의로 변경할 수 있음
- 개발하려는 서버 프로그램의 목적, 개발 언어, 규모 등의 이유로 통합하거나 세분화할 수 있음

** 구현 과정
1) DTO/VO 구현 : 데이터 교환을 위해 사용할 객체를 만드는 과정 / 송수신할 데이터의 '자료형(Data Type)' 에 맞는 변수 및 객체를 생성함
2) SQL 구현 : 데이터의 삽입, 변경, 삭제 등 작업을 수행할 SQL문을 생성하는 과정 / SQL 문은 소스 코드 내에 직접 입력, 또는 별도의 XML 파일로 관리
3) DAO 구현 : 데이터베이스에 접근하고 SQL을 활용하여 데이터를 실제로 조작하는 코드를 구현하는 과정
4) Service 구현 : 사용자의 요청에 응답하기 위한 로직을 구현하는 과정
5) Controller 구현 : 사용자의 요청에 적절한 서비스를 호출하여, 그 결과를 사용자에게 반환하는 코드를 구현하는 과정


# 13. 보안 및 API

* 소프트웨어 개발 보안
- 소프트웨어 개발 과정에서 발생할 수 있는 보안 취약점을 최소화하여 보안 위협으로부터 안전한 소프트웨어를 개발하기 위한 일련의 보안 활동
- 데이터의 '기밀성(Confidentiality)', '무결성(Integrity)', '가용성(Availability)' 등 보안 요소를 충족시키는 것을 목표로 함
- 정부에서 제공하는 소프트웨어 개발 보안 가이드를 참고하여 소프트웨어 개발 과정에서 점검해야 할 보안 항목들을 점검함

* 소프트웨어 개발 보안 점검 항목
1) 세션 통제 : 세션의 연결과 연결로 인해 발생하는 정보를 관리하는 것
2) 입력 데이터 검증 및 표현 : 입력 데이터에 대한 유효성 검증체계를 갖추고, 검증 실패 시 이를 처리할 수 있도록 코딩하는 것
3) 보안 기능 : 인증, 접근 제어, 기밀성, 암호화 등의 기능
4) 시간 및 상태 : 동시 수행을 지원하는 병렬 처리 시스템이나 다수의 프로세스가 동작하는 환경에서 시간과 실행 상태를 관리하여 시스템이 원할히 동작하도록 코딩하는 것
5) 에러 처리 : 소프트웨어 실행 중 발생할 수 있는 오류들을 사전에 정의하여 에러로 인해 발생할 수 있는 문제들을 예방하는 것
6) 코드 오류 : 개발자들이 코딩 중 실수하기 쉬운 형(Type) 변환, 자원의 변환 등을 고려하여 코딩하는 것
7) 캡슐화 : 속성과 데이터를 처리하는 함수를 하나의 객체로 묶어 코딩하는 것
8) API 오용 : API를 잘못 사용하거나 보안에 취약한 API를 사용하지 않도록 고려하여 코딩하는 것

* API (Application Programming Interface)
- 응용 프로그램 개발 시 운영체제나 프로그래밍 언어 등에 있는 '라이브러리를 이용할 수 있도록 규칙 등을 정의해 놓은 인터페이스'
- 라이브러리에 있는 다양한 기능들을 손쉽게 이용할 수 있도록 도와주므로 효율적인 개발이 가능
- 누구나 무료로 사용할 수 있게 공개된 API를 'Open API' 라고 함

** API 종류
- Windows API, 단일 유닉스 규격(SUS), Java API, 웹 API


# 14. 배치 프로그램

* 배치 프로그램 (Batch Program)
- 사용자의 상호 작용 없이 '여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램'

** 배치 프로그램의 필수 요소
1) 대용량 데이터 : 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함
2) 자동화 : 심각한 오류가 발생하는 상황을 제외하고는 사요앚의 개입 없이 수행되어야 함
3) 견고성 : 잘못된 데이터나 '데이터 중복' 등의 상황으로 중단되는 일 없이 수행되어야 함
4) 안정성 / 신뢰성 : 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함
5) 성능 : 다른 응용 프로그램의 수행을 방해하지 않아야 함 / 지정된 시간 내에 처리가 완료되어야 함

* 배치 스케줄러 (Batch Scheduler)
- '일괄 처리(Batch Processing)' 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구
- 특정 '업무(Job)' 를 원하는 시간에 처리할 수 있도록 지원한다는 특성 때문에 '잡 스케줄러(Job Scheduler)' 라고 불림

** 배치 스케줄러의 종류
1) 스프링 배치 (Spring Batch)
- Spring Source 사와 Accenture 사가 2007년 공동 개발한 오픈 소스 프레임워크
- 로그 관리, 추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작 등 다양한 기능을 제공함

2) Quartz
- 스프링 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리
- 수행할 작업과 수행 시간을 관리하는 요소들을 분리하여 일괄 처리 작업에 유연성을 제공

3) Cron
- 리눅스의 기본 스케줄러 도구 / 'crontab' 명령어를 통해 작업을 예약할 수 있음


# 15. 패키지 소프트웨어

* 패키지 소프트웨어 (Package Software)
- '기업에서 일반적으로 사용하는 여러 기능을 통합하여 제공하는 소프트웨어'
- 기업에서는 패키지 소프트웨어를 구입하여 기업 환경에 적합하게 '커스터마이징(Customizing)' 하여 사용함
- 패키지 소프트웨어를 이용하여 시스템을 구축하는 방식을 '패키지 개발 방식' 이라고 함
- 기능 요구사항은 70% 이상 충족시키는 패키지 소프트웨어가 있을 때만 사용하는 것이 적합
- 업무 특성에 맞게 전용으로 개발되는 소프트웨어와 비교하여 안정성, 라이선스, 생산성 등에서 차이가 있음

* 패키지 소프트웨어와 전용 개발 소프트웨어 비교
- 기능 요구 사항 : 70% 이상 충족시키는 패키지 소프트웨어가 있는 경우 이용 / 모든 기능 요구사항 반영 가능
- 안정성 : 품질이 검증되었고, 업계 표준 준용 / 개발자의 역량에 따라 달라짐
- 라이선스 : 판매자 / 회사
- 생산성 : 개발을 위한 인력과 시간이 절약됨 / 개발을 위한 인력과 시간이 필요
- 호환성 : 보장이 안됨 / 설계 단계부터 고려하여 개발
- 유지보수 : 결함 발생 시 즉시 대응이 어려움 / 결함 발생 시 즉시 대응 가능

** 전용 개발 소프트웨어 : 패키지 소프트웨어에 대응되는 용어로, 사업 환경에 맞춰 직접 개발한 소프트웨어



# 01. 개발 환경 구축

* 개발 환경 구축
- 응용 소프트웨어 개발을 위해 '개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것'
- 개발 환경은 응용 소프트웨어가 운영될 환경과 유사한 구조로 구축함
- 분석 단계의 산출물을 바탕으로 개발에 필요한 하드웨어와 소프트웨어를 선정
- 하드웨어와 소프트웨어의 성능, 편의성, 라이선스 등 비즈니스 환경에 적합한 제품들을 최종적으로 결정하여 구축

* 하드웨어 환경
- 사용자의 인터페이스 역할을 하는 '클라이언트(Client)' 그리고 클라이언트와 통신하여 서비스를 제공하는 '서버(Server)' 로 구성됨

** 클라이언트의 종류 : 개인용 컴퓨터(PC), 스마트폰 등

** 서버의 종류
1) 웹 서버 (Web Server) : 클라이언트로부터 직접 요청을 받아 처리함 / 저용량의 정적 파일들을 제공함
2) 웹 애플리케이션 서버 (WAS, Web Application Server) : 동적 서비스를 제공하거나, 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할을 수행함
3) 데이터베이스 서버 (DB Server) : 데이터베이스와 이를 관리하는 DBMS를 운영함
4) 파일 서버 (File Server) : 데이터베이스에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장함

* 소프트웨어 환경
- 클라이언트 서버 운영을 위한 '시스템 소프트웨어' 와 개발에 사용되는 '개발 소프트웨어' 로 구성됨

** 시스템 소프트웨어의 종류 : 운영체제(OS), 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS 등

** 개발 소프트웨어의 종류
1) 요구사항 관리 도구 : 요구사항 수집과 분석, 추적 등 편리하게 도와주는 소프트웨어
2) 설계 / 모델링 도구 : UML(통합 모델링 언어)을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 소프트웨어
3) 구현 도구 : 개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 SW
4) 빌드 도구 : 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 SW
5) 테스트 도구 : 모듈들이 요구사항에 적합하게 구현되었는지 테스트하는 SW
6) 형상 관리 도구 : 산출물들을 버전별로 관리하여 품질 향상을 지원하는 SW

* 웹 서버 (Web Server) 의 기능
1) HTTP/HTTPS 지원 : 브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜
2) 통신 기록 (Communication Log) : 처리한 요청들을 로그 파일로 기록하는 기능
3) 정적 파일 관리 (Managing Static Files) : HTML, CSS, 이미지 등 정적 파일들을 저장하고 관리하는 기능
4) 대역폭 제한 (Bandwidth Throttling) : 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능
5) 가상 호스팅 (Virtual Hosting) : 하나의 서버로 여러 개의 도메인 이름을 연결하는 기능
6) 인증 (Authentication) : 사용자가 합법적인 사용자인지를 확인하는 기능

* 개발 언어의 선정 기준
- 적정성 : 개발하려는 소프트웨어의 목적에 적합해야 함
- 효율성 : 코드의 작성 및 구현이 효율적이어야 함
- 이식성 : 다양한 시스템 및 환경에 적용이 가능해야 함
- 친밀성 : 개발 언어에 대한 개발자들의 이해도와 활용도가 높아야 함
- 범용성 : 다른 개발 사례가 존재하고 여러 분야에서 활용되고 있어야 함


# 02. 소프트웨어 아키텍쳐

* 소프트웨어 아키텍처
- '소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체'
- 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정함
- 소프트웨어 아키텍처 설계의 기본 원리에는 '모듈화', '추상화', '단계적 분해', '정보 은닉' 이 있음

* 모듈화 (Modularity)
- 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 '시스템의 기능을 모듈 단위로 나누는 것'
- 모듈의 크기를 너무 '작게' 나누면 개수가 '많아져' 모듈 간의 '통합 비용이 많이 듦'
- 모듈의 크기를 너무 '크게' 나누면 개수가 '적어' 통합 비용은 '적게' 들지만, '모듈 하나의 개발 비용이 많이 듦'

* 추상화 (Abstraction)
- 문제의 '전체적이고 포괄적인 개념을 설계한 후', 차례로 세분화하여 '구체화시켜 나가는 것'
- 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인들을 테스트할 수 있음

** 추상화의 유형
1) 과정 추상화 : 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
2) 데이터 추상화 : 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
3) 제어 추상화 : 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법

* 단계적 분해 (Stepwise Refinement)
- 문제를 '상위의 중요 개념으로부터 하위의 개념으로 구체화 시키는 분할 기법'
- Niklaus Wirth 에 의해 제안된 '하향식' 설계 전략
- 소프트웨어의 포괄적인 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행

* 정보 은닉 (Information Hiding)
- 한 '모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법'
- 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있음
- 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이

* 상위 설계와 하위 설계
- 상위 설계 : 아키텍처, 예비 설계 / 시스템의 전체적인 구조 / 구조, DB, 인터페이스
- 하위 설계 : 모듈, 상세 설계 / 시스템의 내부 구조 및 행위 / 컴포넌트, 자료 구조, 알고리즘

* 소프트웨어 아키텍처의 품질 속성
- 소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지 확인하기 위해 품질 평가 요소들을 구체화 시켜 놓은 것

** 품질 평가 요소의 종류
1) 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성 등
2) 비즈니스 측면 : 시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개 일정 등
3) 아키텍처 측면 : 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성 등

* 소프트웨어 아키텍처의 설계 과정
1) 설계 목표 설정 : 요구사항을 분석하여 전체 시스템의 설계 목표 설정
2) 시스템 타입 결정 : 시스템과 서브 시스템의 타입을 결정하고, 아키텍처 패턴 선택
3) 아키텍처 패턴 적용 : 시스템의 표준 아키텍처 설계
4) 서브 시스템 구체화 : 서브 시스템의 기능 및 서브 시스템 간의 상호작용을 위한 동작과 인터페이스 정의
5) 검토 : 설계 목표, 요구 사항, 설계의 기본 원리 등을 만족하는지 아키텍처 검토

* 협약 (Contract) 에 의한 설계
- '컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것'
- 컴포넌트에 대한 정확한 인터페이스를 명세함

** 명세에 포함될 조건
1) 선행 조건 (Precondition) : 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
2) 결과 조건 (Postcondition) : 오퍼레이션이 수행된 후 만족되어야 할 조건
3) 불변 조건 (Invariant) : 오퍼레이션이 실행되는 동안 항상 만족디어야 할 조건


# 03. 아키텍처 패턴

* 아키텍처 패턴 (Patterns)
- '아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제'
- 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시
- 아키텍처 패턴에는 서브 시스템들과 그 역할이 정의되어 있음
- 서브 시스템 사이의 관계와 여러 규칙, 지침 등이 포함되어 있음

** 아키텍처 패턴의 종류
1) 레이어 패턴 (Layers Pattern)
- '시스템을 계층으로 구분하여 구성하는' 고전적인 방법의 패턴
- 상위 계층은 하위 계층에 대한 '서비스 제공자'가 되고, 하위 계층은 상위 계층의 '클라이언트' 가 됨
- 서로 마주보는 2개의 계층 사이에서만 상호작용이 이루어짐
- 대표적으로 'OSI 참조 모델' 이 있음

2) 클라이언트 - 서버 패턴 (Client - Server Pattern)
- '하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴'
- 사용자 클라이언트를 통해 서버에 요청하면 클라이언트가 응답을 받아 사용자에게 제공하는 방식

3) 파이프 - 필터 패턴 (Pipe - Filter Pattern)
- '데이터 스트림 절차' 의 각 단계를 '필터로 캡슐화하여 파이프를 통해 전송하는 패턴'
- 앞 시스템의 처리 결과물을 '파이프'를 통해 전달받아 처리한 후, 그 결과물을 다시 파이프를 통해 다음 시스템으로 넘겨주는 패턴을 반복
- 데이터 변환, 버퍼링, 동기화 등에 주로 사용됨
- 대표적으로 UNIX의 '쉘(shell)' 이 있음

4) 모델 - 뷰 - 컨트롤러 패턴 (Model - View - Controller Pattern)
- '서브 시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴'
- '컨트롤러' 가 사용자의 요청을 받으면 핵심 기능과 데이터를 보관하는 '모델' 을 이용하여 '뷰'에 정보를 출력하는 구조
- 여러 개의 뷰를 만들 수 있음 / 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 '대화형 애플리케이션' 에 적합함

* 기타 패턴
1) 마스터-슬레이브 패턴 (Master-Slave Pattern)
- '슬레이브 컴포넌트' 에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴 / ex) 장애 허용 시스템, 병렬 컴퓨팅 시스템

2) 브로커 패턴 (Broker Pattern)
- 사용자가 원하는 서비스와 특성을 '브로커 컴포넌트' 에 요청하면 브로커 컴포넌트가 요청에 맞는 '컴포넌트'와 '연결지'를 연결해주는 패턴 / ex) 분산 환경 시스템

3) 피어-투-피어 패턴 (Peer-To-Peer Pattern)
- '피어(Peer)' 라 불리는 하나의 컴포넌트가 클라이언트가 될 수도, 서버가 될 수도 있는 패턴 / ex) 파일 공유 네트워크

4) 이벤트-버스 패턴 (Event-Bus Pettern)
- 소스가 특정 채널에 이벤트 메시지를 '발행(Publish)' 하면, 해당 채널을 '구독(Subscribe)' 한 '리스터(Listener)' 들이 메시지를 받아 이벤트 처리하는 패턴 / ex) 알림 서비스

5) 블랙보드 패턴 (Blackboard Pattern)
- 모든 컴포넌트들이 '공유 데이터 저장소' 와 '블랙보드 컴포넌트' 에 접근이 가능한 패턴 / ex) 음성 인식, 차량 식별, 신호 해석

6) 인터프리터 패턴 (Interpreter Pattern)
- 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴 / ex 번역기, 컴파일러, 인터프리터


# 04. 객체 지향 (Object-Oriented)

* 객체 지향
- 소프트웨어의 '각 요소들을 객체(Object) 로 만든 후, 객체들을 조립해서 소프트웨어를 개발하는 기법
- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있음
- 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고, 유지보수가 쉬움

** 객체지향의 구성 요소
1) 객체 (Obejct)
- '데이터'와 이를 처리하기 위한 '함수'를 묶어 놓은 소프트웨어 모듈
  -- 데이터 : 객체가 가지고 있는 정보로, 속성이나 상태, 분류 등 (변수, 상수, 자료 구조라고도 함)
  -- 함수 : 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘 / 객체의 상태를 참조하거나 변경하는 수단 (메소드, 서비스, 동작, 연산이라고도 함)

2) 클래스 (Class)
- 공통된 '속성'과 '연산'을 갖는 객체의 집합
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
- 클래스에 속한 각각의 객체를 '인스턴스(Instance)' 라고 함

3) 메시지 (Message)
- '객체들 간의 상호작용에 사용되는 수단으로, 객체의 동작이나 연산을 일으키는 외부의 요구사항'
- 메시지를 받은 객체는 대응하는 연산을 수행하여 예상된 결과를 반환함

** 객체 지향의 특징
1) 캡슐화 (Encapsulation)
- '외부에서 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것'
- 캡슐화된 객체는 외부 모듈의 변경으로 인한 파급 효과가 '적음'
- 객체들 간에 메시지를 주고 받을 때, 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 '단순해지고', 객체 간의 결합도가 '낮아짐'

2) 상속 (Inheritance)
- '상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것'
- '하위 클래스' 는 물려받은 속성과 연산을 다시 정의하지 않아도 즉시 자신의 속성으로 사용할 수 있음
- '하위 클래스' 는 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있음

3) 다형성 (Polymorphism)
- '하나의 메시지에 대해 각각의 객체가' 가지고 있는 '고유한 방법으로 응답할 수 있는 능력'
- 객체들은 동일한 메소드명을 사용하며, 같은 의미의 응답을 함 ex) '+' 연산자의 경우, 숫자 클래스에서는 덧셈, 문자 클래스에서는 문자열의 연결 기능으로 사용됨

4) 연관성 (Relationship)
- '두 개 이상의 객체들이 상호 참조하는 관계'

** 연관성의 종류
- is member of : 연관화 (Association) : 2개 이상의 객체가 상호 관련되어 있음을 의미
- is instance of : 분류화 (Classification) : 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것
- is part of : 집단화 (Aggregation) : 관련 있는 객체들을 묶어 하나의 '상위 객체'를 구성하는 것
- is a : 일반화 (Generalization) : 공통적인 성질들로 추상화한 '상위 객체'를 구성하는 것
       : 특수화/상세화 (Specialization) : 상위 객체를 구체화하여 '하위 객체'를 구성하는 것


# 05. 객체 지향 분석 및 설계

* 객체 지향 분석 (OOA, Object oriented Analysis)
- '사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업'
- 개발을 위한 업무를 '객체' 와 '속성', '클래스' 와 '맴버', '전체' 와 '부분' 등으로 나누어서 분석함
- '클래스'를 식별하는 것이 객체 지향 분석의 주요 목적

* 객체 지향 분석의 방법론
1) Rumbaugh (럼바우) 방법 : 분석 활동을 '객체 모델', '동적 모델', '기능 모델' 로 나누어 수행
2) Booch (부치) 방법 : '미시적(Micro)' 개발 프로세스와 '거시적(Macro)' 개발 프로세스를 모두 사용 / 클래스오 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
3) Jacobson 방법 : '유스케이스(Use Case)' 를 강조하여 사용
4) Coad와 Yourdon 방법 : 'E-R 다이어그램' 을 사용하여 객체의 행위를 모델링함 / 객체 식별, 구조 식별, 주체 정의, 속성 과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성함
5) Wirfs-Brock 방법 : 분석과 설계 간의 구분이 없고, '고객 명세서' 를 평가해서 설계 작업까지 연속적으로 수행함

* 럼바우 (Rumbaugh)의 분석 기법
- '모든 소프트웨어 구성 요소를 "그래픽 표기법" 을 이용하여 모델링하는 기법'
- '객체 모델링 기법(OMT, Object Modeling Technique)' 이라고도 함
- 분석 활동은 '객체 모델링 => 동적 모델링 => 기능 모델링' 순으로 이루어 짐
  -- 객체 모델링 (Object Modeling) : '정보 모델링' 이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 '객체 다이어그램' 으로 표시하는 것
  -- 동적 모델링 (Dynamic Modeling) : '상태 다이어그램' 을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
  -- 기능 모델링 (Function Modeling) : '자료 흐름도(DFD)' 를 이용하여 다수의 프로세스들 간 자료 흐름을 중심으로 처리 과정을 표현한 모델링

* 객체 지향 설계 원칙
- '변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 원칙'
- SRP, OCP, LSP, ISP, DIP 의 다섯 가지 원칙의 앞 글자를 따 'SOLID 원칙' 이라고 부름

** 종류





































































